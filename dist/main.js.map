{"version":3,"file":"main.js","sources":["../src/constants.ts","../src/cube/constants.ts","../src/math.ts","../src/cube/geometry.ts","../src/cube/parsing/color.ts","../src/cube/drawing.tsx","../src/cube/simulation.ts","../src/cube/parsing/arrow.ts","../src/cube/masking.ts","../src/cube/parsing/algorithm.ts","../src/cube/parsing/faceletDefinitions.ts","../src/index.tsx","../src/cube/parsing/options.ts","../src/cube/parsing/colorScheme.ts","../src/cube/parsing/rotation.ts","../src/cube/parsing/faceletColors.ts","../src/cube/stickers.ts"],"sourcesContent":["import { Face } from '..'\r\n\r\nexport enum ColorCode {\r\n  Black = '#000000',\r\n  DarkGray = '#404040',\r\n  Gray = '#808080',\r\n  Silver = '#BFBFBF',\r\n  White = '#FFFFFF',\r\n  Yellow = '#FEFE00',\r\n  Red = '#EE0000',\r\n  Orange = '#FFA100',\r\n  Blue = '#0000F2',\r\n  Green = '#00D800',\r\n  Purple = '#A83DD9',\r\n  Pink = '#F33D7B',\r\n  Transparent = 'transparent',\r\n}\r\n\r\nexport enum ColorName {\r\n  Black = 'black',\r\n  DarkGray = 'darkGray',\r\n  Gray = 'gray',\r\n  Silver = 'silver',\r\n  White = 'white',\r\n  Yellow = 'yellow',\r\n  Red = 'red',\r\n  Orange = 'orange',\r\n  Blue = 'blue',\r\n  Green = 'green',\r\n  Purple = 'purple',\r\n  Pink = 'pink',\r\n  Transparent = 'transparent',\r\n}\r\n\r\nexport enum ColorAbbreviation {\r\n  Black = 'n',\r\n  DarkGray = 'd',\r\n  Gray = 'l',\r\n  Silver = 's',\r\n  White = 'w',\r\n  Yellow = 'y',\r\n  Red = 'r',\r\n  Orange = 'o',\r\n  Blue = 'b',\r\n  Green = 'g',\r\n  Purple = 'm',\r\n  Pink = 'p',\r\n  Transparent = 't',\r\n}\r\n\r\nexport enum FaceletDefinition {\r\n  Up = 'u',\r\n  Down = 'd',\r\n  Left = 'l',\r\n  Right = 'r',\r\n  Back = 'b',\r\n  Front = 'f',\r\n  Transparent = 't',\r\n  Oriented = 'o',\r\n  Blank = 'n',\r\n}\r\n\r\nexport const ColorNameToCode: { [name: string]: ColorCode } = {\r\n  [ColorName.Black]: ColorCode.Black,\r\n  [ColorName.DarkGray]: ColorCode.DarkGray,\r\n  [ColorName.Gray]: ColorCode.Gray,\r\n  [ColorName.Silver]: ColorCode.Silver,\r\n  [ColorName.White]: ColorCode.White,\r\n  [ColorName.Yellow]: ColorCode.Yellow,\r\n  [ColorName.Red]: ColorCode.Red,\r\n  [ColorName.Orange]: ColorCode.Orange,\r\n  [ColorName.Blue]: ColorCode.Blue,\r\n  [ColorName.Green]: ColorCode.Green,\r\n  [ColorName.Purple]: ColorCode.Purple,\r\n  [ColorName.Pink]: ColorCode.Pink,\r\n}\r\n\r\nexport const ColorAbbreviationToCode: { [name: string]: ColorCode } = {\r\n  [ColorAbbreviation.Black]: ColorCode.Black,\r\n  [ColorAbbreviation.DarkGray]: ColorCode.DarkGray,\r\n  [ColorAbbreviation.Gray]: ColorCode.Gray,\r\n  [ColorAbbreviation.Silver]: ColorCode.Silver,\r\n  [ColorAbbreviation.White]: ColorCode.White,\r\n  [ColorAbbreviation.Yellow]: ColorCode.Yellow,\r\n  [ColorAbbreviation.Red]: ColorCode.Red,\r\n  [ColorAbbreviation.Orange]: ColorCode.Orange,\r\n  [ColorAbbreviation.Blue]: ColorCode.Blue,\r\n  [ColorAbbreviation.Green]: ColorCode.Green,\r\n  [ColorAbbreviation.Purple]: ColorCode.Purple,\r\n  [ColorAbbreviation.Pink]: ColorCode.Pink,\r\n  [ColorAbbreviation.Transparent]: ColorCode.Transparent,\r\n}\r\n\r\nexport const FaceletAbbreviateToDefinition: { [facelet: string]: FaceletDefinition } = {\r\n  u: FaceletDefinition.Up,\r\n  f: FaceletDefinition.Front,\r\n  r: FaceletDefinition.Right,\r\n  d: FaceletDefinition.Down,\r\n  l: FaceletDefinition.Left,\r\n  b: FaceletDefinition.Back,\r\n  t: FaceletDefinition.Transparent,\r\n  o: FaceletDefinition.Oriented,\r\n  n: FaceletDefinition.Blank,\r\n}\r\n\r\nexport const FaceletToFace: { [facelet: string]: Face } = {\r\n  [FaceletDefinition.Up]: Face.U,\r\n  [FaceletDefinition.Down]: Face.D,\r\n  [FaceletDefinition.Left]: Face.L,\r\n  [FaceletDefinition.Right]: Face.R,\r\n  [FaceletDefinition.Front]: Face.F,\r\n  [FaceletDefinition.Back]: Face.B,\r\n}\r\n\r\nexport const FaceletToColor = {\r\n  [FaceletDefinition.Oriented]: ColorName.Gray,\r\n  [FaceletDefinition.Blank]: ColorCode.DarkGray,\r\n  [FaceletDefinition.Transparent]: ColorName.Transparent,\r\n}\r\n","import { ColorCode } from './../constants'\r\nimport { ICubeColorScheme } from './models/color-scheme'\r\nimport { Axis } from '../..'\r\n\r\nexport enum Face {\r\n  U = 0,\r\n  R = 1,\r\n  F = 2,\r\n  D = 3,\r\n  L = 4,\r\n  B = 5,\r\n}\r\n\r\nexport const AllFaces = [Face.U, Face.R, Face.F, Face.D, Face.L, Face.B]\r\n\r\nexport class FaceRotationVectors {\r\n  static U = [0, -1, 0]\r\n  static R = [1, 0, 0]\r\n  static F = [0, 0, -1]\r\n  static D = [0, 1, 0]\r\n  static L = [-1, 0, 0]\r\n  static B = [0, 0, 1]\r\n}\r\n\r\nexport const DefaultColorScheme: ICubeColorScheme = {\r\n  [Face.U]: ColorCode.Yellow,\r\n  [Face.R]: ColorCode.Red,\r\n  [Face.F]: ColorCode.Blue,\r\n  [Face.D]: ColorCode.White,\r\n  [Face.L]: ColorCode.Orange,\r\n  [Face.B]: ColorCode.Green,\r\n}\r\n\r\nexport const JapaneseColorScheme: ICubeColorScheme = {\r\n  [Face.U]: ColorCode.Blue,\r\n  [Face.R]: ColorCode.Orange,\r\n  [Face.F]: ColorCode.Green,\r\n  [Face.D]: ColorCode.White,\r\n  [Face.L]: ColorCode.Red,\r\n  [Face.B]: ColorCode.Yellow,\r\n}\r\n\r\nexport enum AlgorithmUnit {\r\n  F = 'F',\r\n  U = 'U',\r\n  R = 'R',\r\n  L = 'L',\r\n  D = 'D',\r\n  B = 'B',\r\n  M = 'M',\r\n  E = 'E',\r\n  S = 'S',\r\n  X = 'x',\r\n  Y = 'y',\r\n  Z = 'z',\r\n}\r\n\r\nexport const AxisSymbolToAxis = {\r\n  x: Axis.X,\r\n  y: Axis.Y,\r\n  z: Axis.Z,\r\n}\r\n\r\nexport const possibleMoves: string[] = [\r\n  AlgorithmUnit.F,\r\n  AlgorithmUnit.U,\r\n  AlgorithmUnit.R,\r\n  AlgorithmUnit.L,\r\n  AlgorithmUnit.D,\r\n  AlgorithmUnit.B,\r\n  AlgorithmUnit.M,\r\n  AlgorithmUnit.E,\r\n  AlgorithmUnit.S,\r\n  AlgorithmUnit.X,\r\n  AlgorithmUnit.Y,\r\n  AlgorithmUnit.Z,\r\n]\r\n\r\nexport const cubeRotations: string[] = [AlgorithmUnit.X, AlgorithmUnit.Y, AlgorithmUnit.Z]\r\n\r\nexport enum TurnAbbreviation {\r\n  Clockwise = '',\r\n  CounterClockwise = \"'\",\r\n  Double = '2',\r\n}\r\n\r\nexport enum Masking {\r\n  FL = 'fl',\r\n  F2L = 'f2l',\r\n  LL = 'll',\r\n  CLL = 'cll',\r\n  ELL = 'ell',\r\n  OLL = 'oll',\r\n  OCLL = 'ocll',\r\n  OELL = 'oell',\r\n  COLL = 'coll',\r\n  OCELL = 'ocell',\r\n  WV = 'wv',\r\n  VH = 'vh',\r\n  ELS = 'els',\r\n  CLS = 'cls',\r\n  CMLL = 'cmll',\r\n  CROSS = 'cross',\r\n  F2L3 = 'f2l_3',\r\n  F2L2 = 'f2l_2',\r\n  F2LSM = 'f2l_sm',\r\n  F2L1 = 'f2l_1',\r\n  F2B = 'f2b',\r\n  LINE = 'line',\r\n}\r\n","/**\r\n * Methods for manipulating points in 3d space (Vec3)\r\n */\r\n\r\nexport type Vec3 = [number, number, number]\r\n\r\nexport enum Axis {\r\n  X = 0,\r\n  Y = 1,\r\n  Z = 2,\r\n}\r\n\r\nexport function makeMatrix<T>(rows: number, cols: number): T[][] {\r\n  let matrix: T[][] = []\r\n  for (let r = 0; r < rows; r++) {\r\n    matrix[r] = []\r\n    for (let c = 0; c < cols; c++) {\r\n      matrix[r][c] = null\r\n    }\r\n  }\r\n  return matrix\r\n}\r\n\r\nexport function translate(pos: Vec3, v: Vec3): Vec3 {\r\n  return pos.map((value, index) => value + v[index]) as Vec3\r\n}\r\n\r\nexport function scale(pos: Vec3, scalar: number): Vec3 {\r\n  return pos.map(v => v * scalar) as Vec3\r\n}\r\n\r\n// Scale a point relative to position vector\r\nexport function transScale(pos: Vec3, v: Vec3, scalar: number): Vec3 {\r\n  // Translate each facelet to cf\r\n  let iv: Vec3 = v.map(x => -x) as Vec3\r\n  return translate(scale(translate(pos, iv), scalar), v)\r\n}\r\n\r\nexport function rotate(pos: Vec3, axis: Axis, radians: number): Vec3 {\r\n  let newPosition: Vec3 = [...pos] as Vec3\r\n  switch (axis) {\r\n    case Axis.X:\r\n      newPosition[2] = pos[2] * Math.cos(radians) - pos[1] * Math.sin(radians)\r\n      newPosition[1] = pos[2] * Math.sin(radians) + pos[1] * Math.cos(radians)\r\n      break\r\n    case Axis.Y:\r\n      newPosition[0] = pos[0] * Math.cos(radians) + pos[2] * Math.sin(radians)\r\n      newPosition[2] = -pos[0] * Math.sin(radians) + pos[2] * Math.cos(radians)\r\n      break\r\n    case Axis.Z:\r\n      newPosition[0] = pos[0] * Math.cos(radians) - pos[1] * Math.sin(radians)\r\n      newPosition[1] = pos[0] * Math.sin(radians) + pos[1] * Math.cos(radians)\r\n      break\r\n  }\r\n  return newPosition\r\n}\r\n\r\nexport function project(pos: Vec3, d: number): Vec3 {\r\n  return [\r\n    (pos[0] * d) / pos[2],\r\n    (pos[1] * d) / pos[2],\r\n    pos[2], // Maintain z coordinate to allow use of rendering tricks\r\n  ]\r\n}\r\n\r\nexport function radians2Degrees(radians: number) {\r\n  return (radians * 180) / Math.PI\r\n}\r\n","import { ICubeOptions } from './options'\r\n/**\r\n * Utlity Methods for creating 2D coodinates for svg polygons\r\n */\r\n\r\nimport { Face, AllFaces } from './constants'\r\nimport { Vec3, makeMatrix, translate, scale, rotate, project, Axis } from '../math'\r\n\r\nexport type FaceStickers = Vec3[][]\r\nexport type CubeGeometry = { [face: number]: Vec3[][] }\r\n\r\n/**\r\n * Rotation vectors by face\r\n */\r\nexport type FaceRotations = { [face: number]: Vec3 }\r\n\r\n/**\r\n * Applies set of rotations to all face rotation vectors.\r\n */\r\nexport function rotateFaces(faceRotations: FaceRotations, rotations: [Axis, number][]): FaceRotations {\r\n  return AllFaces.reduce((acc, face) => {\r\n    rotations.forEach(rotation => {\r\n      if (!acc[face]) {\r\n        acc[face] = [...faceRotations[face]]\r\n      }\r\n      acc[face] = rotate(acc[face], rotation[0], (Math.PI * rotation[1]) / 180)\r\n    })\r\n    return acc\r\n  }, {})\r\n}\r\n\r\nexport function makeStickerPosition(face: Face, cubeSize: number, x: number, y: number): Vec3 {\r\n  switch (face) {\r\n    case Face.U:\r\n      return [x, 0, cubeSize - y]\r\n    case Face.R:\r\n      return [cubeSize, y, x]\r\n    case Face.F:\r\n      return [x, y, 0]\r\n    case Face.D:\r\n      return [x, cubeSize, y]\r\n    case Face.L:\r\n      return [0, y, cubeSize - x]\r\n    case Face.B:\r\n      return [cubeSize - x, y, cubeSize]\r\n    default:\r\n      throw new Error(`Unknown cube face: '${face}'`)\r\n  }\r\n}\r\n\r\n/**\r\n * Creates 2D coordinates for stickers of a given face of the cube.\r\n */\r\nexport function makeFaceStickers(face: Face, options: ICubeOptions): FaceStickers {\r\n  let stickers: Vec3[][] = makeMatrix<Vec3>(options.cubeSize + 1, options.cubeSize + 1)\r\n\r\n  for (let row = 0; row <= options.cubeSize; row++) {\r\n    for (let col = 0; col <= options.cubeSize; col++) {\r\n      let sticker = makeStickerPosition(face, options.cubeSize, row, col)\r\n\r\n      // Now scale and tranform point to ensure size/pos independent of dim\r\n      let centerTranslation: Vec3 = [-options.cubeSize / 2, -options.cubeSize / 2, -options.cubeSize / 2]\r\n      sticker = translate(sticker, centerTranslation)\r\n      sticker = scale(sticker, 1 / options.cubeSize)\r\n\r\n      // Rotate cube as per perameter settings\r\n      options.viewportRotations.forEach(rotation => {\r\n        sticker = rotate(sticker, rotation[0], (Math.PI * rotation[1]) / 180)\r\n      })\r\n\r\n      // Move cube away from viewer\r\n      sticker = translate(sticker, [0, 0, options.dist])\r\n      // Finally project the 3D points onto 2D\r\n      sticker = project(sticker, options.dist)\r\n\r\n      stickers[row][col] = sticker\r\n    }\r\n  }\r\n\r\n  return stickers\r\n}\r\n\r\n/**\r\n * Creates geometry for rubiks cube stickers. Contains 2D coordinates\r\n * for drawing svg polygons\r\n */\r\nexport function makeCubeGeometry(options: ICubeOptions): CubeGeometry {\r\n  if (options.view === 'plan') {\r\n    options.viewportRotations = [[Axis.X, -90]]\r\n  }\r\n  return AllFaces.reduce(\r\n    (acc, face) => {\r\n      acc[face] = makeFaceStickers(face, options)\r\n      return acc\r\n    },\r\n    {} as CubeGeometry\r\n  )\r\n}\r\n","import { ColorAbbreviationToCode, ColorNameToCode, ColorCode } from '../../constants'\r\n\r\nexport function parseColor(raw: string): string | ColorCode {\r\n  let colorcodeRegex = /^[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/\r\n\r\n  // Append # for color codes\r\n  if (colorcodeRegex.exec(raw)) {\r\n    return `#${raw}`\r\n  }\r\n\r\n  if (ColorAbbreviationToCode[raw]) {\r\n    return ColorAbbreviationToCode[raw]\r\n  }\r\n\r\n  if (ColorNameToCode[raw]) {\r\n    return ColorNameToCode[raw]\r\n  }\r\n\r\n  // Default color\r\n  return ColorCode.Gray\r\n}\r\n","import React, { ComponentType, FC } from 'react'\r\nimport { Svg, Polygon, G, Path, Rect } from 'react-native-svg'\r\nimport { ColorName, FaceletToFace, FaceletToColor, ColorCode } from '../constants'\r\nimport { CubeGeometry, FaceStickers, FaceRotations, rotateFaces } from './geometry'\r\nimport { Vec3, transScale, scale, translate, radians2Degrees } from '../math'\r\nimport { Face, AllFaces } from './constants'\r\nimport { ICubeOptions } from './options'\r\nimport { Arrow } from './models/arrow'\r\nimport { parseArrows } from './parsing/arrow'\r\n\r\n/**\r\n * Utility methods for rendering cube geometry using svg.js\r\n */\r\n\r\n// Rotation vectors to track visibility of each face\r\nconst defaultFaceRotations: FaceRotations = {\r\n  [Face.U]: [0, -1, 0],\r\n  [Face.R]: [1, 0, 0],\r\n  [Face.F]: [0, 0, -1],\r\n  [Face.D]: [0, 1, 1],\r\n  [Face.L]: [-1, 0, 0],\r\n  [Face.B]: [0, 0, 1],\r\n}\r\n\r\nfunction viewBox(x: number, y: number, width: number, height: number) {\r\n  return `${x} ${y} ${width} ${height}`\r\n}\r\n\r\nfunction polygonPoints(points: number[][]) {\r\n  return points.map(point => point.join(',')).join(' ')\r\n}\r\n\r\n/**\r\n * Determines face render order based on z position. Faces further away\r\n * will render first so anything closer will be drawn on top.\r\n */\r\nfunction getRenderOrder(faceRotations: FaceRotations): Face[] {\r\n  let renderOrder = [...AllFaces].sort((a: Face, b: Face) => {\r\n    return faceRotations[b][2] - faceRotations[a][2]\r\n  })\r\n  return renderOrder\r\n}\r\n\r\nconst Background: FC<{ options: ICubeOptions }> = ({ options }) => {\r\n  let fill: string\r\n  let fillOpacity: number | undefined = undefined\r\n\r\n  if (!options.backgroundColor) {\r\n    fill = 'none'\r\n    fillOpacity = 0\r\n  } else {\r\n    fill = options.backgroundColor\r\n  }\r\n\r\n  return <Rect {...options.viewbox} fill={fill} fillOpacity={fillOpacity} />\r\n}\r\n\r\nfunction faceVisible(face: Face, rotations: FaceRotations) {\r\n  return rotations[face][2] < -0.105\r\n}\r\n\r\nconst CubeOutlineGroup: FC<{ options: ICubeOptions }> = ({ options, children }) => {\r\n  return <G opacity={options.cubeOpacity / 100} strokeWidth={0.1} strokeLinejoin=\"round\" children={children} />\r\n}\r\n\r\nconst OllLayerGroup: FC<{ options: ICubeOptions }> = ({ options, children }) => {\r\n  return (\r\n    <G\r\n      opacity={options.stickerOpacity / 100}\r\n      strokeOpacity={1}\r\n      strokeWidth={0.02}\r\n      strokeLinejoin=\"round\"\r\n      children={children}\r\n    />\r\n  )\r\n}\r\n\r\nconst ArrowGroup: FC<{ cubeSize: number }> = ({ cubeSize, children }) => {\r\n  return <G opacity={1} strokeOpacity={1} strokeWidth={0.12 / cubeSize} strokeLinecap=\"round\" children={children} />\r\n}\r\n\r\nconst CubeOutline: FC<{ face: FaceStickers; options: ICubeOptions }> = ({ face, options }) => {\r\n  const cubeSize = face.length - 1\r\n  const width = options.outlineWidth\r\n  let outlinePoints = [\r\n    [face[0][0][0] * width, face[0][0][1] * width],\r\n    [face[cubeSize][0][0] * width, face[cubeSize][0][1] * width],\r\n    [face[cubeSize][cubeSize][0] * width, face[cubeSize][cubeSize][1] * width],\r\n    [face[0][cubeSize][0] * width, face[0][cubeSize][1] * width],\r\n  ]\r\n\r\n  return <Polygon fill={options.cubeColor} stroke={options.cubeColor} points={polygonPoints(outlinePoints)} />\r\n}\r\n\r\nexport const FaceStickersSvg: FC<{ face: Face; stickers: FaceStickers; options: ICubeOptions }> = ({\r\n  face,\r\n  stickers,\r\n  options,\r\n}) => {\r\n  const cubeSize = stickers.length - 1\r\n\r\n  const stickerElements: JSX.Element[] = []\r\n\r\n  for (let i = 0; i < cubeSize; i++) {\r\n    for (let j = 0; j < cubeSize; j++) {\r\n      let centerPoint: Vec3 = [\r\n        (stickers[j][i][0] + stickers[j + 1][i + 1][0]) / 2,\r\n        (stickers[j][i][1] + stickers[j + 1][i + 1][1]) / 2,\r\n        0,\r\n      ]\r\n\r\n      // Scale points in towards centre\r\n      let p1 = transScale(stickers[j][i], centerPoint, 0.85)\r\n      let p2 = transScale(stickers[j + 1][i], centerPoint, 0.85)\r\n      let p3 = transScale(stickers[j + 1][i + 1], centerPoint, 0.85)\r\n      let p4 = transScale(stickers[j][i + 1], centerPoint, 0.85)\r\n\r\n      let color = getStickerColor(face, i, j, options)\r\n      if (color !== ColorName.Transparent) {\r\n        stickerElements.push(\r\n          <Sticker key={`${i},${j}`} {...{ p1, p2, p3, p4 }} stickerColor={color} cubeColor={options.cubeColor} />\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  return (\r\n    <G\r\n      opacity={options.stickerOpacity / 100}\r\n      strokeOpacity={0.5}\r\n      strokeWidth={options.strokeWidth}\r\n      strokeLinejoin=\"round\"\r\n      children={stickerElements}\r\n    />\r\n  )\r\n}\r\n\r\nconst Sticker: ComponentType<{\r\n  p1: Vec3\r\n  p2: Vec3\r\n  p3: Vec3\r\n  p4: Vec3\r\n  stickerColor: string\r\n  cubeColor: string\r\n}> = props => {\r\n  const { p1, p2, p3, p4, stickerColor, cubeColor } = props\r\n  let stickerPoints = [[p1[0], p1[1]], [p2[0], p2[1]], [p3[0], p3[1]], [p4[0], p4[1]]]\r\n\r\n  return <Polygon fill={stickerColor} stroke={cubeColor} points={polygonPoints(stickerPoints)} />\r\n}\r\n\r\n/**\r\n * Starting with U, stickers are numbered from\r\n * their face starting with the top left corner\r\n * sticker.\r\n *\r\n * U Face\r\n * 1 | 2 | 3\r\n * ----------\r\n * 4 | 5 | 6\r\n * ----------\r\n * 7 | 8 | 9\r\n *\r\n * And so on for faces R, F, D, L, B.\r\n * So R's top left corner for a 3x3 cube would be # 10\r\n *\r\n * An individual sticker's color is obtained by indexing\r\n * into the array of sticker colors by the number the sticker is\r\n */\r\nfunction getStickerColor(face: Face, row: number, col: number, options: ICubeOptions): string {\r\n  const faceIndex = AllFaces.indexOf(face)\r\n  const stickerNumber = row * options.cubeSize + col\r\n  const colorIndex = faceIndex * (options.cubeSize * options.cubeSize) + stickerNumber\r\n\r\n  if (!Array.isArray(options.facelets) && Array.isArray(options.stickerColors)) {\r\n    if (options.stickerColors.length <= colorIndex) {\r\n      return ColorName.Black\r\n    }\r\n\r\n    return options.stickerColors[colorIndex]\r\n  } else if (Array.isArray(options.facelets)) {\r\n    if (options.facelets.length <= colorIndex) {\r\n      return ColorCode.DarkGray\r\n    }\r\n\r\n    let fd = options.facelets[colorIndex]\r\n    if (FaceletToFace[fd] != null) {\r\n      const face = FaceletToFace[fd]\r\n      return options.colorScheme[face]\r\n    }\r\n\r\n    return FaceletToColor[fd] || ColorCode.DarkGray\r\n  } else {\r\n    return options.colorScheme[face] || ColorName.Black\r\n  }\r\n}\r\n\r\n// Renders the top rim of the R U L and B faces out from side of cube\r\nexport const OLLStickers: FC<{\r\n  face: Face\r\n  stickers: FaceStickers\r\n  rotations: FaceRotations\r\n  options: ICubeOptions\r\n}> = props => {\r\n  const { face, stickers, rotations, options } = props\r\n\r\n  const stickerElements = []\r\n\r\n  // Translation vector, to move faces out\r\n  let v1 = scale(rotations[face], 0)\r\n  let v2 = scale(rotations[face], 0.2)\r\n  for (let i = 0; i < options.cubeSize; i++) {\r\n    // find center point of sticker\r\n    const centerPoint: Vec3 = [\r\n      (stickers[i][0][0] + stickers[i + 1][1][0]) / 2,\r\n      (stickers[i][0][1] + stickers[i + 1][1][1]) / 2,\r\n      0,\r\n    ]\r\n    let p1 = translate(transScale(stickers[i][0], centerPoint, 0.94), v1)\r\n    let p2 = translate(transScale(stickers[i + 1][0], centerPoint, 0.94), v1)\r\n    let p3 = translate(transScale(stickers[i + 1][1], centerPoint, 0.94), v2)\r\n    let p4 = translate(transScale(stickers[i][1], centerPoint, 0.94), v2)\r\n\r\n    let stickerColor = getStickerColor(face, 0, i, options)\r\n\r\n    if (stickerColor !== ColorName.Transparent) {\r\n      stickerElements.push(<Sticker key={i} {...{ p1, p2, p3, p4, stickerColor }} cubeColor={options.cubeColor} />)\r\n    }\r\n  }\r\n\r\n  return <>{stickerElements}</>\r\n}\r\n\r\n/**\r\n * Generates svg for an arrow pointing from sticker s1 to s2\r\n */\r\nexport const ArrowSvg: FC<{ geometry: CubeGeometry; arrow: Arrow }> = ({ geometry, arrow }) => {\r\n  let cubeSize = geometry[0].length - 1\r\n\r\n  // Find center point for each facelet\r\n  let p1y = Math.floor(arrow.s1.n / cubeSize)\r\n  let p1x = arrow.s1.n % cubeSize\r\n  let p1: Vec3 = [\r\n    (geometry[arrow.s1.face][p1x][p1y][0] + geometry[arrow.s1.face][p1x + 1][p1y + 1][0]) / 2,\r\n    (geometry[arrow.s1.face][p1x][p1y][1] + geometry[arrow.s1.face][p1x + 1][p1y + 1][1]) / 2,\r\n    0,\r\n  ]\r\n\r\n  let p2y = Math.floor(arrow.s2.n / cubeSize)\r\n  let p2x = arrow.s2.n % cubeSize\r\n  let p2: Vec3 = [\r\n    (geometry[arrow.s1.face][p2x][p2y][0] + geometry[arrow.s1.face][p2x + 1][p2y + 1][0]) / 2,\r\n    (geometry[arrow.s1.face][p2x][p2y][1] + geometry[arrow.s1.face][p2x + 1][p2y + 1][1]) / 2,\r\n    0,\r\n  ]\r\n\r\n  // Find midpoint between p1 and p2\r\n  let center: Vec3 = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2, 0]\r\n\r\n  // Shorten arrows towards midpoint according to config\r\n  p1 = transScale(p1, center, arrow.scale / 10)\r\n  p2 = transScale(p2, center, arrow.scale / 10)\r\n\r\n  let p3: Vec3\r\n  if (arrow.s3) {\r\n    let p3y = Math.floor(arrow.s3.n / cubeSize)\r\n    let p3x = arrow.s3.n % cubeSize\r\n    p3 = [\r\n      (geometry[arrow.s1.face][p3x][p3y][0] + geometry[arrow.s1.face][p3x + 1][p3y + 1][0]) / 2,\r\n      (geometry[arrow.s1.face][p3x][p3y][1] + geometry[arrow.s1.face][p3x + 1][p3y + 1][1]) / 2,\r\n      0,\r\n    ]\r\n    p3 = transScale(p3, center, arrow.influence / 5)\r\n  }\r\n\r\n  // Calculate arrow rotation\r\n  let p_ = p3 ? p3 : p1\r\n  let rotation = p_[1] > p2[1] ? 270 : 90\r\n  if (p2[0] - p_[0] != 0) {\r\n    rotation = radians2Degrees(Math.atan((p2[1] - p_[1]) / (p2[0] - p_[0])))\r\n    rotation = p_[0] > p2[0] ? rotation + 180 : rotation\r\n  }\r\n\r\n  // Draw line\r\n  let lineSvg = (\r\n    <Path\r\n      d={`M ${p1[0]},${p1[1]} ${p3 ? 'Q ' + p3[0] + ',' + p3[1] : 'L'} ${p2[0]},${p2[1]}`}\r\n      fill=\"none\"\r\n      stroke={arrow.color}\r\n      strokeOpacity={1}\r\n    />\r\n  )\r\n\r\n  // Draw arrow head\r\n  let headSvg = (\r\n    <Path\r\n      d=\"M 5.77,0.0 L -2.88,5.0 L -2.88,-5.0 L 5.77,0.0 z\"\r\n      translate={[p2[0], p2[1]]}\r\n      scale={0.033 / cubeSize}\r\n      rotation={rotation}\r\n      fill={arrow.color}\r\n      strokeWidth={0}\r\n      strokeLinejoin=\"round\"\r\n    />\r\n  )\r\n\r\n  return (\r\n    <>\r\n      {lineSvg}\r\n      {headSvg}\r\n    </>\r\n  )\r\n}\r\n\r\nexport const Cube: FC<{ geometry: CubeGeometry; options: ICubeOptions }> = ({ geometry, options }) => {\r\n  let faceRotations = rotateFaces(defaultFaceRotations, options.viewportRotations)\r\n  let renderOrder = getRenderOrder(faceRotations)\r\n\r\n  let hiddenFaces = renderOrder.filter(face => !faceVisible(face, faceRotations))\r\n  let visibleFaces = renderOrder.filter(face => faceVisible(face, faceRotations))\r\n\r\n  let arrowDefinitions: Arrow[] = []\r\n\r\n  if (Array.isArray(options.arrows)) {\r\n    arrowDefinitions = options.arrows\r\n  } else if (typeof options.arrows === 'string') {\r\n    arrowDefinitions = parseArrows(options.arrows)\r\n  }\r\n\r\n  return (\r\n    <Svg\r\n      width={options.width}\r\n      height={options.height}\r\n      viewBox={viewBox(options.viewbox.x, options.viewbox.y, options.viewbox.width, options.viewbox.height)}\r\n    >\r\n      <Background options={options} />\r\n      {options.cubeOpacity < 100 && (\r\n        <>\r\n          <CubeOutlineGroup options={options}>\r\n            {hiddenFaces.map(face => (\r\n              <CubeOutline face={geometry[face]} options={options} />\r\n            ))}\r\n          </CubeOutlineGroup>\r\n          {hiddenFaces.map(face => (\r\n            <FaceStickersSvg face={face} stickers={geometry[face]} options={options} />\r\n          ))}\r\n        </>\r\n      )}\r\n\r\n      <CubeOutlineGroup options={options}>\r\n        {visibleFaces.map(face => (\r\n          <CubeOutline face={geometry[face]} options={options} />\r\n        ))}\r\n      </CubeOutlineGroup>\r\n\r\n      {visibleFaces.map(face => (\r\n        <FaceStickersSvg face={face} stickers={geometry[face]} options={options} />\r\n      ))}\r\n\r\n      {options.view === 'plan' && (\r\n        <OllLayerGroup options={options}>\r\n          {[Face.R, Face.F, Face.L, Face.B].map(face => (\r\n            <OLLStickers face={face} stickers={geometry[face]} rotations={faceRotations} options={options} />\r\n          ))}\r\n        </OllLayerGroup>\r\n      )}\r\n\r\n      <ArrowGroup cubeSize={geometry[0].length - 1}>\r\n        {arrowDefinitions.map(arrow => (\r\n          <ArrowSvg geometry={geometry} arrow={arrow} />\r\n        ))}\r\n      </ArrowGroup>\r\n    </Svg>\r\n  )\r\n}\r\n","import { Axis } from './../math'\r\nimport { AllFaces, Face, AlgorithmUnit } from './constants'\r\nimport { Turn } from './parsing/algorithm'\r\n\r\nexport enum TurnType {\r\n  Clockwise,\r\n  CounterClockwise,\r\n  Double,\r\n}\r\n\r\n// Given sticker N return sticker number after rotation\r\ntype FaceRotation = (stickerNumber: number, cubeSize: number) => number\r\n\r\nconst faceIdentity: FaceRotation = (stickerNumber: number, cubeSize: number) => stickerNumber\r\nconst counterClockwiseSticker: FaceRotation = (stickerNumber, cubeSize) =>\r\n  (stickerNumber * cubeSize) % (cubeSize * cubeSize + 1)\r\nconst clockwiseSticker: FaceRotation = (stickerNumber, cubeSize) => {\r\n  let numStickers = cubeSize * cubeSize\r\n  return numStickers + 1 - counterClockwiseSticker(stickerNumber, cubeSize)\r\n}\r\nconst doubleTurn: FaceRotation = (stickerNumber, cubeSize) => {\r\n  return cubeSize * cubeSize - stickerNumber + 1\r\n}\r\n\r\nconst OppositeTurn = {\r\n  [TurnType.Clockwise]: TurnType.CounterClockwise,\r\n  [TurnType.CounterClockwise]: TurnType.Clockwise,\r\n  [TurnType.Double]: TurnType.Double,\r\n}\r\n\r\n// Faces that wrap around a given axis\r\nconst AxisMapping = {\r\n  [Axis.X]: [Face.U, Face.B, Face.F, Face.D],\r\n  [Axis.Y]: [Face.L, Face.B, Face.R, Face.F],\r\n  [Axis.Z]: [Face.L, Face.U, Face.R, Face.D],\r\n}\r\n\r\n// Face's orientation related to other faces on a given axis\r\nconst AxisOrientation: { [axis: number]: { [face: number]: FaceRotation } } = {\r\n  [Axis.X]: {\r\n    [Face.U]: faceIdentity,\r\n    [Face.B]: doubleTurn,\r\n    [Face.F]: faceIdentity,\r\n    [Face.D]: faceIdentity,\r\n    [Face.L]: null,\r\n    [Face.R]: null,\r\n  },\r\n  [Axis.Y]: {\r\n    [Face.U]: null,\r\n    [Face.B]: counterClockwiseSticker,\r\n    [Face.F]: counterClockwiseSticker,\r\n    [Face.D]: null,\r\n    [Face.L]: counterClockwiseSticker,\r\n    [Face.R]: counterClockwiseSticker,\r\n  },\r\n  [Axis.Z]: {\r\n    [Face.U]: counterClockwiseSticker,\r\n    [Face.B]: null,\r\n    [Face.F]: null,\r\n    [Face.D]: clockwiseSticker,\r\n    [Face.L]: faceIdentity,\r\n    [Face.R]: doubleTurn,\r\n  },\r\n}\r\n\r\nexport class CubeData {\r\n  /**\r\n   *  Data to store face value\r\n   *  data saved in flat array [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n   *  maps to cube stickers like this\r\n   *\r\n   *  U Face\r\n   *  1 | 2 | 3\r\n   *  ----------\r\n   *  4 | 5 | 6\r\n   *  ----------\r\n   *  7 | 8 | 9\r\n   *\r\n   *  Stickers are numbered in that manner starting with the U face\r\n   *  continuing with this order U, R, F, D, L, B\r\n   *\r\n   *  Because each face has a differen't orientation it may not be clear\r\n   *  how the back faces are numbered. Below is an example 3x3 mapping\r\n   *\r\n   *  Example numbers of 3x3 cube. nxn cubes follow the same pattern\r\n   *\r\n   *        B\r\n   *      L U R\r\n   *        F\r\n   *        D\r\n   *                  | 54  | 53  | 52  |\r\n   *                   -----------------\r\n   *                  | 51  | 50  | 49  |\r\n   *                   -----------------\r\n   *                  | 48  | 47  | 46  |\r\n   * -----------------                   -----------------\r\n   *  43  | 40  | 37     1  |  2  |  3    12  | 15  | 18\r\n   * ----------------- ----------------- -----------------\r\n   *  44  | 41  | 38     4  |  5  |  6    11  | 14  | 17\r\n   * ----------------- ----------------- -----------------\r\n   *  45  | 42  | 39     7  |  8  |  9    10  | 13  | 16\r\n   * -----------------                   -----------------\r\n   *                  | 19  | 20  | 21  |\r\n   *                   -----------------\r\n   *                  | 22  | 23  | 24  |\r\n   *                   -----------------\r\n   *                  | 25  | 26  | 27  |\r\n   *\r\n   *                  | 28  | 29  | 30  |\r\n   *                   -----------------\r\n   *                  | 31  | 32  | 33  |\r\n   *                   -----------------\r\n   *                  | 34  | 35  | 36  |\r\n   */\r\n  public faces: { [face: number]: any[] } = {}\r\n  private numStickers: number\r\n\r\n  // Precalculated index mapping values for face rotations\r\n  private clockwiseMapping: number[]\r\n  private counterClockwiseMapping: number[]\r\n  private doubleMapping: number[]\r\n\r\n  constructor(private cubeSize: number, initialValues?: { [face: number]: any[] }) {\r\n    this.numStickers = this.cubeSize * this.cubeSize\r\n    this.clockwiseMapping = []\r\n    this.counterClockwiseMapping = []\r\n    this.doubleMapping = []\r\n\r\n    this.faces = initialValues\r\n\r\n    if (!this.faces) {\r\n      this.initValues()\r\n    }\r\n\r\n    for (let i = 1; i <= this.numStickers; i++) {\r\n      this.clockwiseMapping.push(clockwiseSticker(i, cubeSize))\r\n      this.counterClockwiseMapping.push(counterClockwiseSticker(i, cubeSize))\r\n      this.doubleMapping.push(doubleTurn(i, cubeSize))\r\n    }\r\n  }\r\n\r\n  private initValues() {\r\n    let currentValue = 1\r\n    AllFaces.forEach(face => {\r\n      this.faces[face] = []\r\n      for (let i = 0; i < this.numStickers; i++) {\r\n        this.faces[face].push(currentValue++)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Rotates values on an outer face of the rubiks cubes\r\n   */\r\n  private rotateFace(face: Face, turn: TurnType) {\r\n    // TODO more efficient rotation to not construct so many new arrays\r\n    switch (turn) {\r\n      case TurnType.Clockwise:\r\n        this.faces[face] = this.clockwiseMapping.map(newStickerNumber => this.faces[face][newStickerNumber - 1])\r\n        break\r\n      case TurnType.CounterClockwise:\r\n        this.faces[face] = this.counterClockwiseMapping.map(newStickerNumber => this.faces[face][newStickerNumber - 1])\r\n        break\r\n      case TurnType.Double:\r\n        this.faces[face].reverse()\r\n        break\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rotates layer values around a given axis\r\n   */\r\n  private axisRotation(\r\n    offset: number,\r\n    range: number,\r\n    axis: Axis,\r\n    faceOrder: Face[],\r\n    forward: boolean = true,\r\n    double: boolean = false\r\n  ) {\r\n    if (!forward) {\r\n      faceOrder.reverse()\r\n    }\r\n\r\n    // Copy original values to avoid clobbering values when modifying stickers\r\n    let originalValues = faceOrder.map(face => this.faces[face].slice())\r\n\r\n    // Copy values\r\n    for (let i = 0; i < this.cubeSize; i++) {\r\n      for (let r = 0; r < range; r++) {\r\n        const stickerIndex = this.cubeSize * i + (offset + r)\r\n        for (let j = 0; j < faceOrder.length; j++) {\r\n          const face = faceOrder[j]\r\n          const nextFace = double ? faceOrder[(j + 2) % faceOrder.length] : faceOrder[(j + 1) % faceOrder.length]\r\n          const valueIndex = AxisOrientation[axis][face](stickerIndex + 1, this.cubeSize) - 1\r\n          const nextFaceValueIndex = AxisOrientation[axis][nextFace](stickerIndex + 1, this.cubeSize) - 1\r\n          this.faces[face][valueIndex] =\r\n            originalValues[(double ? j + 2 : j + 1) % originalValues.length][nextFaceValueIndex]\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rotate layers around the x axis of the cube\r\n   */\r\n  private xLayersRotation(offset: number, forward: boolean = true, double: boolean = false, range: number = 1) {\r\n    let faceOrder = [Face.U, Face.F, Face.D, Face.B]\r\n    this.axisRotation(offset, range, Axis.X, faceOrder, forward, double)\r\n  }\r\n\r\n  /**\r\n   * Rotate layers around the y axis of the cube\r\n   */\r\n  private yLayersRotation(offset: number, forward: boolean = true, double: boolean = false, range: number = 1) {\r\n    let faceOrder = [Face.L, Face.F, Face.R, Face.B]\r\n    this.axisRotation(offset, range, Axis.Y, faceOrder, forward, double)\r\n  }\r\n\r\n  /**\r\n   * Rotate layers around the z axis of the cube\r\n   */\r\n  private zLayersRotation(offset: number, forward: boolean = true, double: boolean = false, range: number = 1) {\r\n    let faceOrder = [Face.U, Face.L, Face.D, Face.R]\r\n    this.axisRotation(offset, range, Axis.Z, faceOrder, forward, double)\r\n  }\r\n\r\n  /**\r\n   * Restricts the number of slices used in outer block moves to the cube size\r\n   */\r\n  private safeSlices(n: number): number {\r\n    return n > this.cubeSize ? this.cubeSize : n\r\n  }\r\n\r\n  rTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.R, turnType)\r\n    let offset = this.cubeSize - slices\r\n    this.xLayersRotation(offset, turnType === TurnType.Clockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  lTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.L, turnType)\r\n    this.xLayersRotation(0, turnType === TurnType.CounterClockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  uTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.U, turnType)\r\n    this.yLayersRotation(0, turnType === TurnType.Clockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  dTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.D, turnType)\r\n    let offset = this.cubeSize - slices\r\n    this.yLayersRotation(offset, turnType === TurnType.CounterClockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  fTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.F, turnType)\r\n    let offset = this.cubeSize - slices\r\n    this.zLayersRotation(offset, turnType === TurnType.Clockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  bTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.B, turnType)\r\n    this.zLayersRotation(0, turnType === TurnType.CounterClockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  mTurn(turnType: TurnType) {\r\n    if (this.cubeSize < 2) return\r\n    this.xLayersRotation(1, turnType === TurnType.CounterClockwise, turnType === TurnType.Double, this.cubeSize - 2)\r\n  }\r\n\r\n  eTurn(turnType: TurnType) {\r\n    if (this.cubeSize < 2) return\r\n    this.yLayersRotation(1, turnType === TurnType.CounterClockwise, turnType === TurnType.Double, this.cubeSize - 2)\r\n  }\r\n\r\n  sTurn(turnType: TurnType) {\r\n    if (this.cubeSize < 2) return\r\n    this.zLayersRotation(1, turnType === TurnType.Clockwise, turnType === TurnType.Double, this.cubeSize - 2)\r\n  }\r\n\r\n  xTurn(turnType: TurnType) {\r\n    this.rotateFace(Face.R, turnType)\r\n    this.rotateFace(Face.L, OppositeTurn[turnType])\r\n    this.xLayersRotation(0, turnType === TurnType.Clockwise, turnType === TurnType.Double, this.cubeSize)\r\n  }\r\n\r\n  yTurn(turnType: TurnType) {\r\n    this.rotateFace(Face.U, turnType)\r\n    this.rotateFace(Face.D, OppositeTurn[turnType])\r\n    this.yLayersRotation(0, turnType === TurnType.Clockwise, turnType === TurnType.Double, this.cubeSize)\r\n  }\r\n\r\n  zTurn(turnType: TurnType) {\r\n    this.rotateFace(Face.F, turnType)\r\n    this.rotateFace(Face.B, OppositeTurn[turnType])\r\n    this.zLayersRotation(0, turnType === TurnType.Clockwise, turnType === TurnType.Double, this.cubeSize)\r\n  }\r\n\r\n  turn(turn: Turn) {\r\n    let slices = this.safeSlices(turn.slices)\r\n    switch (turn.move) {\r\n      case AlgorithmUnit.F:\r\n        this.fTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.B:\r\n        this.bTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.U:\r\n        this.uTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.D:\r\n        this.dTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.R:\r\n        this.rTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.L:\r\n        this.lTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.M:\r\n        this.mTurn(turn.turnType)\r\n        break\r\n      case AlgorithmUnit.E:\r\n        this.eTurn(turn.turnType)\r\n        break\r\n      case AlgorithmUnit.S:\r\n        this.sTurn(turn.turnType)\r\n        break\r\n      case AlgorithmUnit.X:\r\n        this.xTurn(turn.turnType)\r\n        break\r\n      case AlgorithmUnit.Y:\r\n        this.yTurn(turn.turnType)\r\n        break\r\n      case AlgorithmUnit.Z:\r\n        this.zTurn(turn.turnType)\r\n        break\r\n      default:\r\n        throw new Error(`Unrecognized move in turn ${JSON.stringify(turn)}`)\r\n    }\r\n  }\r\n}\r\n","import { StickerDefinition } from '../models/sticker'\r\nimport { Arrow } from '../models/arrow'\r\nimport { Face } from '../constants'\r\nimport { ColorCode, ColorName } from '../../constants'\r\nimport { parseColor } from './color'\r\n\r\nconst stickerPattern = '([URFDLB])([0-9]+)'\r\nconst colorPattern =\r\n  '(black|dgrey|grey|silver|white|yellow|red|orange|blue|green|purple|pink|[0-9a-fA-F]{6}|[0-9a-fA-F]{3})'\r\nconst arrowPattern = `^(${stickerPattern})(${stickerPattern})(${stickerPattern})?(-s([0-9+]))?(-i([0-9+]))?(-${colorPattern})?`\r\n\r\nexport function parseArrows(raw: string): Arrow[] {\r\n  if (typeof raw !== 'string') {\r\n    return []\r\n  }\r\n\r\n  return raw\r\n    .split(',')\r\n    .map(part => parseArrow(part))\r\n    .filter(arrow => !!arrow)\r\n}\r\n\r\nexport function parseArrow(raw: string): Arrow {\r\n  if (typeof raw !== 'string') {\r\n    return null\r\n  }\r\n\r\n  let arrowRegex = new RegExp(arrowPattern)\r\n  let match = arrowRegex.exec(raw)\r\n\r\n  if (!match) {\r\n    return null\r\n  }\r\n\r\n  return <Arrow>{\r\n    s1: {\r\n      face: Face[match[2]],\r\n      n: parseInt(match[3]),\r\n    },\r\n    s2: {\r\n      face: Face[match[5]],\r\n      n: parseInt(match[6]),\r\n    },\r\n    s3: !match[7]\r\n      ? undefined\r\n      : {\r\n          face: Face[match[8]],\r\n          n: parseInt(match[9]),\r\n        },\r\n    color: match[15] ? parseColor(match[15]) : ColorCode.Gray,\r\n    scale: match[11] ? parseInt(match[11]) : 10,\r\n    influence: match[13] ? parseInt(match[13]) : 10,\r\n  }\r\n}\r\n","import { Masking, Face, AllFaces } from './constants'\r\n\r\ntype FaceValues = { [face: number]: any[] }\r\ntype MaskingFunctions = {\r\n  [masking: string]: {\r\n    [face: number]: (row: number, col: number, cubeSize: number) => boolean\r\n  }\r\n}\r\n\r\nconst maskingFunctions: MaskingFunctions = {\r\n  [Masking.FL]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row == cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row == cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row == cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row == cubeSize - 1,\r\n  },\r\n  [Masking.F2L]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.LL]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => row == 0,\r\n    [Face.L]: (row, col, cubeSize) => row == 0,\r\n    [Face.F]: (row, col, cubeSize) => row == 0,\r\n    [Face.B]: (row, col, cubeSize) => row == 0,\r\n  },\r\n  [Masking.CLL]: {\r\n    [Face.U]: (row, col, cubeSize) =>\r\n      (row > 0 && col > 0 && row < cubeSize - 1 && col < cubeSize - 1) || // is center\r\n      ((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.L]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.F]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.B]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n  },\r\n  [Masking.ELL]: {\r\n    [Face.U]: (row, col, cubeSize) => !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n  },\r\n  [Masking.OLL]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => false,\r\n    [Face.L]: (row, col, cubeSize) => false,\r\n    [Face.F]: (row, col, cubeSize) => false,\r\n    [Face.B]: (row, col, cubeSize) => false,\r\n  },\r\n  [Masking.OCLL]: {\r\n    [Face.U]: (row, col, cubeSize) =>\r\n      (row > 0 && col > 0 && row < cubeSize - 1 && col < cubeSize - 1) || // is center\r\n      ((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => false,\r\n    [Face.L]: (row, col, cubeSize) => false,\r\n    [Face.F]: (row, col, cubeSize) => false,\r\n    [Face.B]: (row, col, cubeSize) => false,\r\n  },\r\n  [Masking.OELL]: {\r\n    [Face.U]: (row, col, cubeSize) => !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => false,\r\n    [Face.L]: (row, col, cubeSize) => false,\r\n    [Face.F]: (row, col, cubeSize) => false,\r\n    [Face.B]: (row, col, cubeSize) => false,\r\n  },\r\n  [Masking.COLL]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.L]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.F]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.B]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n  },\r\n  [Masking.OCELL]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n  },\r\n  [Masking.WV]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.VH]: {\r\n    [Face.U]: (row, col, cubeSize) => !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.ELS]: {\r\n    [Face.U]: (row, col, cubeSize) => !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => (row == 0 ? col < cubeSize - 1 : true),\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && (row == cubeSize - 1 ? col > 0 : true),\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && (row == cubeSize - 1 ? col < cubeSize - 1 : true),\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.CLS]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.CMLL]: {\r\n    [Face.U]: (row, col, cubeSize) => (row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1),\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row > 0 || col == 0 || col == cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row > 0 || col == 0 || col == cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => col == 0 || col == cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => col == 0 || col == cubeSize - 1,\r\n  },\r\n  [Masking.CROSS]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n  },\r\n  [Masking.F2L3]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) =>\r\n      (row == 0 && col == cubeSize - 1) || !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && col < cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n  },\r\n  [Masking.F2L2]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => row > 0 || (col > 0 && col < cubeSize - 1),\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && col > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.F2LSM]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) =>\r\n      !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)) ||\r\n      (col == 0 && row == cubeSize - 1) ||\r\n      (row == 0 && col == cubeSize - 1),\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && col < cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0 && col > 0,\r\n  },\r\n  [Masking.F2L1]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => row !== 0 || col !== cubeSize - 1,\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && col > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.F2B]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => col == 0 || col == cubeSize - 1,\r\n    [Face.R]: (row, col, cubeSize) => row > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.B]: (row, col, cubeSize) => row > 0 && (col == 0 || col == cubeSize - 1),\r\n  },\r\n  [Masking.LINE]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => col > 0 && col < cubeSize - 1,\r\n    [Face.R]: (row, col, cubeSize) => false,\r\n    [Face.L]: (row, col, cubeSize) => false,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n  },\r\n}\r\n\r\nexport function makeMasking(masking: Masking, cubeSize: number): FaceValues {\r\n  if (!maskingFunctions[masking]) {\r\n    throw new Error(`invalid masking ${masking}`)\r\n  }\r\n\r\n  let numStickers = cubeSize * cubeSize\r\n  let faceValues = {\r\n    [Face.U]: [],\r\n    [Face.F]: [],\r\n    [Face.R]: [],\r\n    [Face.D]: [],\r\n    [Face.L]: [],\r\n    [Face.B]: [],\r\n  }\r\n\r\n  for (let i = 0; i < numStickers; i++) {\r\n    let row = Math.floor(i / cubeSize)\r\n    let col = i % cubeSize\r\n\r\n    AllFaces.forEach(face => {\r\n      faceValues[face].push(maskingFunctions[masking][face](row, col, cubeSize))\r\n    })\r\n  }\r\n\r\n  return faceValues\r\n}\r\n","import { cubeRotations } from './../constants'\r\nimport { TurnType } from '../simulation'\r\nimport { TurnAbbreviation, AlgorithmUnit, possibleMoves } from '../constants'\r\n\r\nexport interface Turn {\r\n  move: AlgorithmUnit\r\n  turnType: TurnType\r\n  slices: number\r\n}\r\n\r\nconst turnRegex = /([2-9]+)?([UuFfRrDdLlBbMESxyz])(w)?([2\\'])?/g\r\n\r\nconst Opposite = {\r\n  [TurnType.Clockwise]: TurnType.CounterClockwise,\r\n  [TurnType.CounterClockwise]: TurnType.Clockwise,\r\n  [TurnType.Double]: TurnType.Double,\r\n}\r\n\r\n/**\r\n * Takes in an algorithm string and parses the turns from it\r\n * algorithm string format should be moves separated by a single space\r\n * (ex. \"U R2 L' x\")\r\n *\r\n * https://www.worldcubeassociation.org/regulations/#article-12-notation\r\n */\r\nexport function parseAlgorithm(algorithm: string): Turn[] {\r\n  if (!algorithm) {\r\n    return []\r\n  }\r\n  let turns: Turn[] = []\r\n  let match\r\n  do {\r\n    match = turnRegex.exec(algorithm)\r\n    if (match) {\r\n      let rawSlices: string = match[1]\r\n      let rawFace: string = match[2]\r\n      let outerBlockIndicator = match[3]\r\n      let rawType = match[4] || TurnAbbreviation.Clockwise // Default to clockwise\r\n      let isLowerCaseMove = rawFace === rawFace.toLowerCase() && cubeRotations.indexOf(rawFace) === -1\r\n\r\n      if (isLowerCaseMove) {\r\n        rawFace = rawFace.toUpperCase()\r\n      }\r\n\r\n      let turn: Turn = {\r\n        move: getMove(rawFace),\r\n        turnType: getTurnType(rawType),\r\n        slices: isLowerCaseMove ? 2 : getSlices(rawSlices, outerBlockIndicator),\r\n      }\r\n\r\n      turns.push(turn)\r\n    }\r\n  } while (match)\r\n\r\n  return turns\r\n}\r\n\r\nexport function parseCase(algorithm: string): Turn[] {\r\n  return parseAlgorithm(algorithm)\r\n    .map(turn => {\r\n      return <Turn>{\r\n        turnType: Opposite[turn.turnType],\r\n        move: turn.move,\r\n        slices: turn.slices,\r\n      }\r\n    })\r\n    .reverse()\r\n}\r\n\r\nfunction getSlices(rawSlices, outerBlockIndicator): number {\r\n  if (outerBlockIndicator && !rawSlices) {\r\n    return 2\r\n  } else if (!outerBlockIndicator && rawSlices) {\r\n    throw new Error(`Invalid move: Cannot specify num slices if outer block move indicator 'w' is not present`)\r\n  } else if (!outerBlockIndicator && !rawSlices) {\r\n    return 1\r\n  } else {\r\n    return parseInt(rawSlices)\r\n  }\r\n}\r\n\r\nfunction getMove(rawFace: string): AlgorithmUnit {\r\n  if (possibleMoves.indexOf(rawFace) < 0) {\r\n    throw new Error(`Invalid move (${rawFace}): Possible turn faces are [U R F L D B M E S x y z]`)\r\n  } else return rawFace as AlgorithmUnit\r\n}\r\n\r\nfunction getTurnType(rawType: string): TurnType {\r\n  switch (rawType) {\r\n    case TurnAbbreviation.Clockwise:\r\n      return TurnType.Clockwise\r\n    case TurnAbbreviation.CounterClockwise:\r\n      return TurnType.CounterClockwise\r\n    case TurnAbbreviation.Double:\r\n      return TurnType.Double\r\n    default:\r\n      throw new Error(`Invalid move modifier (${rawType})`)\r\n  }\r\n}\r\n","import { FaceletDefinition, FaceletAbbreviateToDefinition } from '../../constants'\r\n\r\nexport function parseFaceletDefinitions(rawValue: string): FaceletDefinition[] {\r\n  let colors = []\r\n  for (let i = 0; i < rawValue.length; i++) {\r\n    colors.push(FaceletAbbreviateToDefinition[rawValue.charAt(i)])\r\n  }\r\n  return colors\r\n}\r\n","import React, { FC } from 'react'\r\nimport { makeCubeGeometry } from './cube/geometry'\r\nimport { Axis } from './math'\r\nimport { Cube } from './cube/drawing';\r\nimport { ICubeOptions } from './cube/options'\r\nimport { DefaultColorScheme } from './cube/constants'\r\nimport { makeStickerColors } from './cube/stickers'\r\nimport { ColorName } from './constants'\r\nimport { parseOptions } from './cube/parsing/options'\r\nimport { parseFaceletDefinitions } from './cube/parsing/faceletDefinitions'\r\n\r\nconst defaultOptions: ICubeOptions = {\r\n  cubeSize: 3,\r\n  width: 128,\r\n  height: 128,\r\n  viewportRotations: [[Axis.Y, 45], [Axis.X, -34]],\r\n  colorScheme: DefaultColorScheme,\r\n  cubeColor: ColorName.Black,\r\n  cubeOpacity: 100,\r\n  stickerOpacity: 100,\r\n  dist: 5,\r\n  outlineWidth: 0.94,\r\n  strokeWidth: 0,\r\n  viewbox: {\r\n    x: -0.9,\r\n    y: -0.9,\r\n    width: 1.8,\r\n    height: 1.8,\r\n  },\r\n}\r\n\r\nexport const CubeSvg: FC<{extraOptions?: any}> = (props) => {\r\n  let options = getOptions(defaultOptions, props.extraOptions || {})\r\n  let geometry = makeCubeGeometry(options)\r\n  options.stickerColors = makeStickerColors(options)\r\n\r\n  return <Cube geometry={geometry} options={options} />\r\n}\r\n\r\nfunction getOptions(defaultOptions: ICubeOptions, extraOptions: string | ICubeOptions): ICubeOptions {\r\n  let parsedOptions: ICubeOptions\r\n  if (typeof extraOptions === 'string') {\r\n    parsedOptions = parseOptions(extraOptions)\r\n  } else {\r\n    parsedOptions = extraOptions\r\n  }\r\n\r\n  if (typeof parsedOptions.facelets === 'string') {\r\n    parsedOptions.facelets = parseFaceletDefinitions(parsedOptions.facelets)\r\n  }\r\n\r\n  return { ...defaultOptions, ...parsedOptions }\r\n}\r\n","import { ICubeOptions } from '../options'\r\nimport { parseRotationSequence } from './rotation'\r\nimport { parseFaceletColors } from './faceletColors'\r\nimport { parseColorScheme } from './colorScheme'\r\nimport { parseFaceletDefinitions } from './faceletDefinitions'\r\n\r\n/**\r\n * Utility methods for parsing the old query param style options\r\n */\r\n\r\nexport function parseOptions(rawOptions: string): ICubeOptions {\r\n  let options: ICubeOptions = {} as any\r\n  let params = parseQuery(rawOptions)\r\n\r\n  Object.keys(params).forEach(key => {\r\n    let paramValue = params[key]\r\n    switch (key) {\r\n      case 'pzl':\r\n        options.cubeSize = parseInt(paramValue) || 3\r\n        break\r\n      case 'size':\r\n        let size = parseInt(paramValue) || 250\r\n        options.width = size\r\n        options.height = size\r\n        break\r\n      case 'view':\r\n        options.view = paramValue\r\n        break\r\n      case 'stage':\r\n        options.mask = paramValue\r\n        break\r\n      case 'r':\r\n        options.viewportRotations = parseRotationSequence(paramValue)\r\n        break\r\n      case 'alg':\r\n        options.algorithm = paramValue\r\n        break\r\n      case 'case':\r\n        options.case = paramValue\r\n        break\r\n      case 'fc':\r\n        options.stickerColors = parseFaceletColors(paramValue)\r\n        break\r\n      case 'sch':\r\n        options.colorScheme = parseColorScheme(paramValue)\r\n        break\r\n      case 'bg':\r\n        options.backgroundColor = paramValue\r\n        break\r\n      case 'cc':\r\n        options.cubeColor = paramValue\r\n        break\r\n      case 'co':\r\n        options.cubeOpacity = parseInt(paramValue) || 100\r\n        break\r\n      case 'fo':\r\n        options.stickerOpacity = parseInt(paramValue) || 100\r\n        break\r\n      case 'dist':\r\n        options.dist = parseInt(paramValue) || 5\r\n        break\r\n      case 'arw':\r\n        options.arrows = paramValue\r\n        break\r\n      case 'fd':\r\n        options.facelets = parseFaceletDefinitions(paramValue)\r\n        break\r\n      case 'ac':\r\n        // TODO: Support default arrow color\r\n        console.warn(\"Currently param 'ac' is unsupported\")\r\n        break\r\n    }\r\n  })\r\n  return options\r\n}\r\n\r\nfunction parseQuery(url) {\r\n  let queryString = url.indexOf('?') > -1 ? url.substr(url.indexOf('?') + 1) : url\r\n  var query = {}\r\n  var pairs = queryString.split('&')\r\n  for (var i = 0; i < pairs.length; i++) {\r\n    var pair = pairs[i].split('=')\r\n    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '')\r\n  }\r\n  return query\r\n}\r\n","import { ICubeColorScheme } from '../models/color-scheme'\r\nimport { parseColor } from './color'\r\nimport { ColorCode, ColorNameToCode, ColorAbbreviationToCode } from '../../constants'\r\nimport { AllFaces, DefaultColorScheme } from '../constants'\r\n\r\nexport function parseColorScheme(rawValue: string): ICubeColorScheme {\r\n  if (rawValue.indexOf(',') > -1) {\r\n    return parseCommaSeparatedValues(rawValue)\r\n  } else {\r\n    return parseAbbreviations(rawValue)\r\n  }\r\n}\r\n\r\nfunction parseAbbreviations(rawValue) {\r\n  let scheme: ICubeColorScheme = {}\r\n  if (rawValue.length < AllFaces.length) {\r\n    return DefaultColorScheme\r\n  }\r\n\r\n  AllFaces.forEach((face, index) => {\r\n    if (rawValue.length > index) {\r\n      scheme[face] = ColorAbbreviationToCode[rawValue.charAt(index)]\r\n    }\r\n  })\r\n\r\n  return scheme\r\n}\r\n\r\nfunction parseCommaSeparatedValues(rawValue) {\r\n  let scheme: ICubeColorScheme = {}\r\n\r\n  // Parse as comma separated list of colors\r\n  let rawColors = rawValue.split(',')\r\n  if (rawColors.length < AllFaces.length) {\r\n    return DefaultColorScheme\r\n  }\r\n  AllFaces.forEach((face, index) => {\r\n    if (rawColors.length > index) {\r\n      let parsedColor = parseColor(rawColors[index])\r\n      let colorCode: ColorCode = ColorNameToCode[parsedColor] || (parsedColor as ColorCode)\r\n      if (parsedColor) {\r\n        scheme[face] = colorCode\r\n      }\r\n    }\r\n  })\r\n\r\n  return scheme\r\n}\r\n","import { Axis } from '../../math'\r\nimport { AxisSymbolToAxis } from '../constants'\r\n\r\nexport function parseRotationSequence(rawSequence: string): [Axis, number][] {\r\n  const rotationRegex = /([xyz]-?[0-9][0-9]?[0-9]?)/g\r\n  let match\r\n  let rotations: [Axis, number][] = []\r\n\r\n  do {\r\n    match = rotationRegex.exec(rawSequence)\r\n    if (match) {\r\n      let matchText: string = match[0]\r\n      let axisSymbol = matchText.charAt(0)\r\n      let value = matchText.substr(1)\r\n      let axis = AxisSymbolToAxis[axisSymbol]\r\n      rotations.push([axis, parseInt(value)])\r\n    }\r\n  } while (match)\r\n\r\n  return rotations\r\n}\r\n","import { parseColor } from './color'\r\nimport { ColorAbbreviationToCode } from '../../constants'\r\n\r\nexport function parseFaceletColors(rawValue: string): string[] {\r\n  let colors = []\r\n  if (rawValue.indexOf(',') > -1) {\r\n    // Parse as comma separated colors\r\n    rawValue.split(',').forEach(value => {\r\n      let parsed = parseColor(value)\r\n      if (parsed) {\r\n        colors.push(parsed)\r\n      }\r\n    })\r\n  } else {\r\n    // parse as abbreviations (ex 'yyyyyyyyyrrrrrrrrrbbbbbbbbb....')\r\n    for (let i = 0; i < rawValue.length; i++) {\r\n      colors.push(ColorAbbreviationToCode[rawValue.charAt(i)])\r\n    }\r\n  }\r\n  return colors\r\n}\r\n","import { ICubeOptions } from './options'\r\nimport { makeMasking } from './masking'\r\nimport { CubeData } from './simulation'\r\nimport { parseAlgorithm, parseCase, Turn } from './parsing/algorithm'\r\nimport { AllFaces } from './constants'\r\nimport { ColorName, ColorCode } from '../constants'\r\n\r\nexport function makeStickerColors(options: ICubeOptions): string[] {\r\n  let stickerColors = options.stickerColors\r\n  let mask = options.mask ? makeMasking(options.mask, options.cubeSize) : null\r\n\r\n  if (mask && options.maskAlg) {\r\n    let maskCubeData = new CubeData(options.cubeSize, mask)\r\n    let alg = parseAlgorithm(options.maskAlg)\r\n    alg.forEach(turn => {\r\n      maskCubeData.turn(turn)\r\n    })\r\n    mask = maskCubeData.faces\r\n  }\r\n\r\n  // Fill with color scheme if sticker colors not predefined.\r\n  if (!stickerColors) {\r\n    stickerColors = [].concat.apply(\r\n      [],\r\n      AllFaces.map(face => {\r\n        return Array.apply(null, Array(options.cubeSize * options.cubeSize)).map(() => options.colorScheme[face])\r\n      })\r\n    )\r\n  }\r\n\r\n  let faceMappedStickers = AllFaces.reduce((acc, face) => {\r\n    if (!acc[face]) acc[face] = []\r\n\r\n    for (let i = 0; i < options.cubeSize; i++) {\r\n      for (let j = 0; j < options.cubeSize; j++) {\r\n        const faceIndex = AllFaces.indexOf(face)\r\n        const stickerNumber = i * options.cubeSize + j\r\n        const colorIndex = faceIndex * (options.cubeSize * options.cubeSize) + stickerNumber\r\n\r\n        if (stickerColors.length <= colorIndex) {\r\n          acc[face][options.cubeSize * i + j] = ColorName.Black\r\n        } else {\r\n          acc[face][options.cubeSize * i + j] = stickerColors[colorIndex]\r\n        }\r\n\r\n        if (mask && !mask[face][options.cubeSize * i + j]) {\r\n          acc[face][options.cubeSize * i + j] = ColorCode.DarkGray\r\n        }\r\n      }\r\n    }\r\n\r\n    return acc\r\n  }, {})\r\n\r\n  // Apply Algorithm\r\n  let cubeData = new CubeData(options.cubeSize, faceMappedStickers)\r\n\r\n  let alg: Turn[] = []\r\n\r\n  if (options.case) {\r\n    alg = parseCase(options.case)\r\n  } else if (options.algorithm) {\r\n    alg = parseAlgorithm(options.algorithm)\r\n  }\r\n\r\n  alg.forEach(move => {\r\n    cubeData.turn(move)\r\n  })\r\n\r\n  return [].concat.apply([], AllFaces.map(face => cubeData.faces[face].slice()))\r\n}\r\n"],"names":["ColorCode","ColorName","ColorAbbreviation","FaceletDefinition","Face","ColorNameToCode","Black","DarkGray","Gray","Silver","White","Yellow","Red","Orange","Blue","Green","Purple","Pink","ColorAbbreviationToCode","Transparent","FaceletAbbreviateToDefinition","u","Up","f","Front","r","Right","d","Down","l","Left","b","Back","t","o","Oriented","n","Blank","FaceletToFace","FaceletToColor","AlgorithmUnit","AllFaces","U","R","F","D","L","B","DefaultColorScheme","TurnAbbreviation","Masking","Axis","AxisSymbolToAxis","x","y","z","possibleMoves","M","E","S","X","Y","Z","cubeRotations","translate","pos","v","map","value","index","scale","scalar","transScale","rotate","axis","radians","newPosition","Math","cos","sin","makeStickerPosition","face","cubeSize","Error","parseColor","raw","exec","defaultFaceRotations","polygonPoints","points","point","join","Background","fill","options","fillOpacity","undefined","backgroundColor","Rect","viewbox","faceVisible","rotations","CubeOutlineGroup","G","opacity","cubeOpacity","strokeWidth","strokeLinejoin","children","OllLayerGroup","stickerOpacity","strokeOpacity","ArrowGroup","strokeLinecap","CubeOutline","length","width","outlineWidth","Polygon","cubeColor","stroke","FaceStickersSvg","stickers","stickerElements","i","j","centerPoint","p1","p2","p3","p4","color","getStickerColor","push","h","Sticker","key","stickerColor","props","row","col","colorIndex","indexOf","Array","isArray","facelets","stickerColors","fd","colorScheme","TurnType","OLLStickers","v1","v2","ArrowSvg","geometry","arrow","p1y","floor","s1","p1x","p2y","s2","p2x","center","s3","p3y","p3x","influence","p_","rotation","atan","PI","lineSvg","Path","headSvg","Cube","height","faceRotations","reduce","acc","forEach","rotateFaces","viewportRotations","renderOrder","sort","a","getRenderOrder","hiddenFaces","filter","visibleFaces","arrowDefinitions","arrows","split","part","match","RegExp","parseInt","parseArrow","Svg","viewBox","view","maskingFunctions","FL","F2L","LL","CLL","ELL","OLL","OCLL","OELL","COLL","OCELL","WV","VH","ELS","CLS","CMLL","CROSS","F2L3","F2L2","F2LSM","F2L1","F2B","LINE","faceIdentity","stickerNumber","counterClockwiseSticker","clockwiseSticker","doubleTurn","OppositeTurn","Clockwise","CounterClockwise","Double","AxisOrientation","CubeData","initialValues","this","numStickers","clockwiseMapping","counterClockwiseMapping","doubleMapping","faces","initValues","currentValue","_this","rotateFace","turn","newStickerNumber","_this2","reverse","axisRotation","offset","range","faceOrder","forward","double","originalValues","_this3","slice","stickerIndex","nextFace","valueIndex","nextFaceValueIndex","xLayersRotation","yLayersRotation","zLayersRotation","safeSlices","rTurn","turnType","slices","lTurn","uTurn","dTurn","fTurn","bTurn","mTurn","eTurn","sTurn","xTurn","yTurn","zTurn","move","JSON","stringify","turnRegex","Opposite","parseAlgorithm","algorithm","turns","rawSlices","rawFace","outerBlockIndicator","rawType","isLowerCaseMove","toLowerCase","toUpperCase","getMove","getTurnType","getSlices","parseFaceletDefinitions","rawValue","colors","charAt","defaultOptions","dist","extraOptions","parsedOptions","rawOptions","params","url","query","pairs","substr","pair","decodeURIComponent","parseQuery","Object","keys","paramValue","size","mask","rawSequence","rotationRegex","matchText","axisSymbol","parseRotationSequence","parsed","parseFaceletColors","scheme","rawColors","parsedColor","parseCommaSeparatedValues","parseAbbreviations","console","warn","parseOptions","getOptions","rows","cols","matrix","c","makeMatrix","sticker","makeFaceStickers","makeCubeGeometry","masking","faceValues","makeMasking","maskAlg","maskCubeData","concat","apply","faceMappedStickers","cubeData","alg","makeStickerColors"],"mappings":"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"}