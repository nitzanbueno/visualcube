{"version":3,"file":"index.js","sources":["../src/constants.ts","../src/cube/constants.ts","../src/math.ts","../src/cube/geometry.ts","../src/cube/parsing/color.ts","../src/cube/drawing.tsx","../src/cube/simulation.ts","../src/cube/parsing/arrow.ts","../src/cube/masking.ts","../src/cube/parsing/algorithm.ts","../src/cube/parsing/faceletDefinitions.ts","../src/cubeSvg.tsx","../src/cube/parsing/options.ts","../src/cube/parsing/colorScheme.ts","../src/cube/parsing/rotation.ts","../src/cube/parsing/faceletColors.ts","../src/cube/stickers.ts","../src/index.ts"],"sourcesContent":["import { Face } from '.'\r\n\r\nexport enum ColorCode {\r\n  Black = '#000000',\r\n  DarkGray = '#404040',\r\n  Gray = '#808080',\r\n  Silver = '#BFBFBF',\r\n  White = '#FFFFFF',\r\n  Yellow = '#FEFE00',\r\n  Red = '#EE0000',\r\n  Orange = '#FFA100',\r\n  Blue = '#0000F2',\r\n  Green = '#00D800',\r\n  Purple = '#A83DD9',\r\n  Pink = '#F33D7B',\r\n  Transparent = 'transparent',\r\n}\r\n\r\nexport enum ColorName {\r\n  Black = 'black',\r\n  DarkGray = 'darkGray',\r\n  Gray = 'gray',\r\n  Silver = 'silver',\r\n  White = 'white',\r\n  Yellow = 'yellow',\r\n  Red = 'red',\r\n  Orange = 'orange',\r\n  Blue = 'blue',\r\n  Green = 'green',\r\n  Purple = 'purple',\r\n  Pink = 'pink',\r\n  Transparent = 'transparent',\r\n}\r\n\r\nexport enum ColorAbbreviation {\r\n  Black = 'n',\r\n  DarkGray = 'd',\r\n  Gray = 'l',\r\n  Silver = 's',\r\n  White = 'w',\r\n  Yellow = 'y',\r\n  Red = 'r',\r\n  Orange = 'o',\r\n  Blue = 'b',\r\n  Green = 'g',\r\n  Purple = 'm',\r\n  Pink = 'p',\r\n  Transparent = 't',\r\n}\r\n\r\nexport enum FaceletDefinition {\r\n  Up = 'u',\r\n  Down = 'd',\r\n  Left = 'l',\r\n  Right = 'r',\r\n  Back = 'b',\r\n  Front = 'f',\r\n  Transparent = 't',\r\n  Oriented = 'o',\r\n  Blank = 'n',\r\n}\r\n\r\nexport const ColorNameToCode: { [name: string]: ColorCode } = {\r\n  [ColorName.Black]: ColorCode.Black,\r\n  [ColorName.DarkGray]: ColorCode.DarkGray,\r\n  [ColorName.Gray]: ColorCode.Gray,\r\n  [ColorName.Silver]: ColorCode.Silver,\r\n  [ColorName.White]: ColorCode.White,\r\n  [ColorName.Yellow]: ColorCode.Yellow,\r\n  [ColorName.Red]: ColorCode.Red,\r\n  [ColorName.Orange]: ColorCode.Orange,\r\n  [ColorName.Blue]: ColorCode.Blue,\r\n  [ColorName.Green]: ColorCode.Green,\r\n  [ColorName.Purple]: ColorCode.Purple,\r\n  [ColorName.Pink]: ColorCode.Pink,\r\n}\r\n\r\nexport const ColorAbbreviationToCode: { [name: string]: ColorCode } = {\r\n  [ColorAbbreviation.Black]: ColorCode.Black,\r\n  [ColorAbbreviation.DarkGray]: ColorCode.DarkGray,\r\n  [ColorAbbreviation.Gray]: ColorCode.Gray,\r\n  [ColorAbbreviation.Silver]: ColorCode.Silver,\r\n  [ColorAbbreviation.White]: ColorCode.White,\r\n  [ColorAbbreviation.Yellow]: ColorCode.Yellow,\r\n  [ColorAbbreviation.Red]: ColorCode.Red,\r\n  [ColorAbbreviation.Orange]: ColorCode.Orange,\r\n  [ColorAbbreviation.Blue]: ColorCode.Blue,\r\n  [ColorAbbreviation.Green]: ColorCode.Green,\r\n  [ColorAbbreviation.Purple]: ColorCode.Purple,\r\n  [ColorAbbreviation.Pink]: ColorCode.Pink,\r\n  [ColorAbbreviation.Transparent]: ColorCode.Transparent,\r\n}\r\n\r\nexport const FaceletAbbreviateToDefinition: { [facelet: string]: FaceletDefinition } = {\r\n  u: FaceletDefinition.Up,\r\n  f: FaceletDefinition.Front,\r\n  r: FaceletDefinition.Right,\r\n  d: FaceletDefinition.Down,\r\n  l: FaceletDefinition.Left,\r\n  b: FaceletDefinition.Back,\r\n  t: FaceletDefinition.Transparent,\r\n  o: FaceletDefinition.Oriented,\r\n  n: FaceletDefinition.Blank,\r\n}\r\n\r\nexport const FaceletToFace: { [facelet: string]: Face } = {\r\n  [FaceletDefinition.Up]: Face.U,\r\n  [FaceletDefinition.Down]: Face.D,\r\n  [FaceletDefinition.Left]: Face.L,\r\n  [FaceletDefinition.Right]: Face.R,\r\n  [FaceletDefinition.Front]: Face.F,\r\n  [FaceletDefinition.Back]: Face.B,\r\n}\r\n\r\nexport const FaceletToColor = {\r\n  [FaceletDefinition.Oriented]: ColorName.Gray,\r\n  [FaceletDefinition.Blank]: ColorCode.DarkGray,\r\n  [FaceletDefinition.Transparent]: ColorName.Transparent,\r\n}\r\n","import { ColorCode } from './../constants'\r\nimport { ICubeColorScheme } from './models/color-scheme'\r\nimport { Axis } from '..'\r\n\r\nexport enum Face {\r\n  U = 0,\r\n  R = 1,\r\n  F = 2,\r\n  D = 3,\r\n  L = 4,\r\n  B = 5,\r\n}\r\n\r\nexport const AllFaces = [Face.U, Face.R, Face.F, Face.D, Face.L, Face.B]\r\n\r\nexport class FaceRotationVectors {\r\n  static U = [0, -1, 0]\r\n  static R = [1, 0, 0]\r\n  static F = [0, 0, -1]\r\n  static D = [0, 1, 0]\r\n  static L = [-1, 0, 0]\r\n  static B = [0, 0, 1]\r\n}\r\n\r\nexport const DefaultColorScheme: ICubeColorScheme = {\r\n  [Face.U]: ColorCode.Yellow,\r\n  [Face.R]: ColorCode.Red,\r\n  [Face.F]: ColorCode.Blue,\r\n  [Face.D]: ColorCode.White,\r\n  [Face.L]: ColorCode.Orange,\r\n  [Face.B]: ColorCode.Green,\r\n}\r\n\r\nexport const JapaneseColorScheme: ICubeColorScheme = {\r\n  [Face.U]: ColorCode.Blue,\r\n  [Face.R]: ColorCode.Orange,\r\n  [Face.F]: ColorCode.Green,\r\n  [Face.D]: ColorCode.White,\r\n  [Face.L]: ColorCode.Red,\r\n  [Face.B]: ColorCode.Yellow,\r\n}\r\n\r\nexport enum AlgorithmUnit {\r\n  F = 'F',\r\n  U = 'U',\r\n  R = 'R',\r\n  L = 'L',\r\n  D = 'D',\r\n  B = 'B',\r\n  M = 'M',\r\n  E = 'E',\r\n  S = 'S',\r\n  X = 'x',\r\n  Y = 'y',\r\n  Z = 'z',\r\n}\r\n\r\nexport const AxisSymbolToAxis = {\r\n  x: Axis.X,\r\n  y: Axis.Y,\r\n  z: Axis.Z,\r\n}\r\n\r\nexport const possibleMoves: string[] = [\r\n  AlgorithmUnit.F,\r\n  AlgorithmUnit.U,\r\n  AlgorithmUnit.R,\r\n  AlgorithmUnit.L,\r\n  AlgorithmUnit.D,\r\n  AlgorithmUnit.B,\r\n  AlgorithmUnit.M,\r\n  AlgorithmUnit.E,\r\n  AlgorithmUnit.S,\r\n  AlgorithmUnit.X,\r\n  AlgorithmUnit.Y,\r\n  AlgorithmUnit.Z,\r\n]\r\n\r\nexport const cubeRotations: string[] = [AlgorithmUnit.X, AlgorithmUnit.Y, AlgorithmUnit.Z]\r\n\r\nexport enum TurnAbbreviation {\r\n  Clockwise = '',\r\n  CounterClockwise = \"'\",\r\n  Double = '2',\r\n}\r\n\r\nexport enum Masking {\r\n  FL = 'fl',\r\n  F2L = 'f2l',\r\n  LL = 'll',\r\n  CLL = 'cll',\r\n  ELL = 'ell',\r\n  OLL = 'oll',\r\n  OCLL = 'ocll',\r\n  OELL = 'oell',\r\n  COLL = 'coll',\r\n  OCELL = 'ocell',\r\n  WV = 'wv',\r\n  VH = 'vh',\r\n  ELS = 'els',\r\n  CLS = 'cls',\r\n  CMLL = 'cmll',\r\n  CROSS = 'cross',\r\n  F2L3 = 'f2l_3',\r\n  F2L2 = 'f2l_2',\r\n  F2LSM = 'f2l_sm',\r\n  F2L1 = 'f2l_1',\r\n  F2B = 'f2b',\r\n  LINE = 'line',\r\n}\r\n","/**\r\n * Methods for manipulating points in 3d space (Vec3)\r\n */\r\n\r\nexport type Vec3 = [number, number, number]\r\n\r\nexport enum Axis {\r\n  X = 0,\r\n  Y = 1,\r\n  Z = 2,\r\n}\r\n\r\nexport function makeMatrix<T>(rows: number, cols: number): T[][] {\r\n  let matrix: T[][] = []\r\n  for (let r = 0; r < rows; r++) {\r\n    matrix[r] = []\r\n    for (let c = 0; c < cols; c++) {\r\n      matrix[r][c] = null\r\n    }\r\n  }\r\n  return matrix\r\n}\r\n\r\nexport function translate(pos: Vec3, v: Vec3): Vec3 {\r\n  return pos.map((value, index) => value + v[index]) as Vec3\r\n}\r\n\r\nexport function scale(pos: Vec3, scalar: number): Vec3 {\r\n  return pos.map(v => v * scalar) as Vec3\r\n}\r\n\r\n// Scale a point relative to position vector\r\nexport function transScale(pos: Vec3, v: Vec3, scalar: number): Vec3 {\r\n  // Translate each facelet to cf\r\n  let iv: Vec3 = v.map(x => -x) as Vec3\r\n  return translate(scale(translate(pos, iv), scalar), v)\r\n}\r\n\r\nexport function rotate(pos: Vec3, axis: Axis, radians: number): Vec3 {\r\n  let newPosition: Vec3 = [...pos] as Vec3\r\n  switch (axis) {\r\n    case Axis.X:\r\n      newPosition[2] = pos[2] * Math.cos(radians) - pos[1] * Math.sin(radians)\r\n      newPosition[1] = pos[2] * Math.sin(radians) + pos[1] * Math.cos(radians)\r\n      break\r\n    case Axis.Y:\r\n      newPosition[0] = pos[0] * Math.cos(radians) + pos[2] * Math.sin(radians)\r\n      newPosition[2] = -pos[0] * Math.sin(radians) + pos[2] * Math.cos(radians)\r\n      break\r\n    case Axis.Z:\r\n      newPosition[0] = pos[0] * Math.cos(radians) - pos[1] * Math.sin(radians)\r\n      newPosition[1] = pos[0] * Math.sin(radians) + pos[1] * Math.cos(radians)\r\n      break\r\n  }\r\n  return newPosition\r\n}\r\n\r\nexport function project(pos: Vec3, d: number): Vec3 {\r\n  return [\r\n    (pos[0] * d) / pos[2],\r\n    (pos[1] * d) / pos[2],\r\n    pos[2], // Maintain z coordinate to allow use of rendering tricks\r\n  ]\r\n}\r\n\r\nexport function radians2Degrees(radians: number) {\r\n  return (radians * 180) / Math.PI\r\n}\r\n","import { ICubeOptions } from './options'\r\n/**\r\n * Utlity Methods for creating 2D coodinates for svg polygons\r\n */\r\n\r\nimport { Face, AllFaces } from './constants'\r\nimport { Vec3, makeMatrix, translate, scale, rotate, project, Axis } from '../math'\r\n\r\nexport type FaceStickers = Vec3[][]\r\nexport type CubeGeometry = { [face: number]: Vec3[][] }\r\n\r\n/**\r\n * Rotation vectors by face\r\n */\r\nexport type FaceRotations = { [face: number]: Vec3 }\r\n\r\n/**\r\n * Applies set of rotations to all face rotation vectors.\r\n */\r\nexport function rotateFaces(faceRotations: FaceRotations, rotations: [Axis, number][]): FaceRotations {\r\n  return AllFaces.reduce((acc, face) => {\r\n    rotations.forEach(rotation => {\r\n      if (!acc[face]) {\r\n        acc[face] = [...faceRotations[face]]\r\n      }\r\n      acc[face] = rotate(acc[face], rotation[0], (Math.PI * rotation[1]) / 180)\r\n    })\r\n    return acc\r\n  }, {})\r\n}\r\n\r\nexport function makeStickerPosition(face: Face, cubeSize: number, x: number, y: number): Vec3 {\r\n  switch (face) {\r\n    case Face.U:\r\n      return [x, 0, cubeSize - y]\r\n    case Face.R:\r\n      return [cubeSize, y, x]\r\n    case Face.F:\r\n      return [x, y, 0]\r\n    case Face.D:\r\n      return [x, cubeSize, y]\r\n    case Face.L:\r\n      return [0, y, cubeSize - x]\r\n    case Face.B:\r\n      return [cubeSize - x, y, cubeSize]\r\n    default:\r\n      throw new Error(`Unknown cube face: '${face}'`)\r\n  }\r\n}\r\n\r\n/**\r\n * Creates 2D coordinates for stickers of a given face of the cube.\r\n */\r\nexport function makeFaceStickers(face: Face, options: ICubeOptions): FaceStickers {\r\n  let stickers: Vec3[][] = makeMatrix<Vec3>(options.cubeSize + 1, options.cubeSize + 1)\r\n\r\n  for (let row = 0; row <= options.cubeSize; row++) {\r\n    for (let col = 0; col <= options.cubeSize; col++) {\r\n      let sticker = makeStickerPosition(face, options.cubeSize, row, col)\r\n\r\n      // Now scale and tranform point to ensure size/pos independent of dim\r\n      let centerTranslation: Vec3 = [-options.cubeSize / 2, -options.cubeSize / 2, -options.cubeSize / 2]\r\n      sticker = translate(sticker, centerTranslation)\r\n      sticker = scale(sticker, 1 / options.cubeSize)\r\n\r\n      // Rotate cube as per perameter settings\r\n      options.viewportRotations.forEach(rotation => {\r\n        sticker = rotate(sticker, rotation[0], (Math.PI * rotation[1]) / 180)\r\n      })\r\n\r\n      // Move cube away from viewer\r\n      sticker = translate(sticker, [0, 0, options.dist])\r\n      // Finally project the 3D points onto 2D\r\n      sticker = project(sticker, options.dist)\r\n\r\n      stickers[row][col] = sticker\r\n    }\r\n  }\r\n\r\n  return stickers\r\n}\r\n\r\n/**\r\n * Creates geometry for rubiks cube stickers. Contains 2D coordinates\r\n * for drawing svg polygons\r\n */\r\nexport function makeCubeGeometry(options: ICubeOptions): CubeGeometry {\r\n  if (options.view === 'plan') {\r\n    options.viewportRotations = [[Axis.X, -90]]\r\n  }\r\n  return AllFaces.reduce(\r\n    (acc, face) => {\r\n      acc[face] = makeFaceStickers(face, options)\r\n      return acc\r\n    },\r\n    {} as CubeGeometry\r\n  )\r\n}\r\n","import { ColorAbbreviationToCode, ColorNameToCode, ColorCode } from '../../constants'\r\n\r\nexport function parseColor(raw: string): string | ColorCode {\r\n  let colorcodeRegex = /^[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/\r\n\r\n  // Append # for color codes\r\n  if (colorcodeRegex.exec(raw)) {\r\n    return `#${raw}`\r\n  }\r\n\r\n  if (ColorAbbreviationToCode[raw]) {\r\n    return ColorAbbreviationToCode[raw]\r\n  }\r\n\r\n  if (ColorNameToCode[raw]) {\r\n    return ColorNameToCode[raw]\r\n  }\r\n\r\n  // Default color\r\n  return ColorCode.Gray\r\n}\r\n","import React, { Fragment, ComponentType, FC } from 'react'\r\nimport { Svg, Polygon, G, Path, Rect } from 'react-native-svg'\r\nimport { ColorName, FaceletToFace, FaceletToColor, ColorCode } from '../constants'\r\nimport { CubeGeometry, FaceStickers, FaceRotations, rotateFaces } from './geometry'\r\nimport { Vec3, transScale, scale, translate, radians2Degrees } from '../math'\r\nimport { Face, AllFaces } from './constants'\r\nimport { ICubeOptions } from './options'\r\nimport { Arrow } from './models/arrow'\r\nimport { parseArrows } from './parsing/arrow'\r\n\r\n/**\r\n * Utility methods for rendering cube geometry using svg.js\r\n */\r\n\r\n// Rotation vectors to track visibility of each face\r\nconst defaultFaceRotations: FaceRotations = {\r\n  [Face.U]: [0, -1, 0],\r\n  [Face.R]: [1, 0, 0],\r\n  [Face.F]: [0, 0, -1],\r\n  [Face.D]: [0, 1, 1],\r\n  [Face.L]: [-1, 0, 0],\r\n  [Face.B]: [0, 0, 1],\r\n}\r\n\r\nfunction viewBox(x: number, y: number, width: number, height: number) {\r\n  return `${x} ${y} ${width} ${height}`\r\n}\r\n\r\nfunction polygonPoints(points: number[][]) {\r\n  return points.map(point => point.join(',')).join(' ')\r\n}\r\n\r\n/**\r\n * Determines face render order based on z position. Faces further away\r\n * will render first so anything closer will be drawn on top.\r\n */\r\nfunction getRenderOrder(faceRotations: FaceRotations): Face[] {\r\n  let renderOrder = [...AllFaces].sort((a: Face, b: Face) => {\r\n    return faceRotations[b][2] - faceRotations[a][2]\r\n  })\r\n  return renderOrder\r\n}\r\n\r\nconst Background: FC<{ options: ICubeOptions }> = ({ options }) => {\r\n  let fill: string\r\n  let fillOpacity: number | undefined = undefined\r\n\r\n  if (!options.backgroundColor) {\r\n    fill = 'none'\r\n    fillOpacity = 0\r\n  } else {\r\n    fill = options.backgroundColor\r\n  }\r\n\r\n  return <Rect {...options.viewbox} fill={fill} fillOpacity={fillOpacity} />\r\n}\r\n\r\nfunction faceVisible(face: Face, rotations: FaceRotations) {\r\n  return rotations[face][2] < -0.105\r\n}\r\n\r\nconst CubeOutlineGroup: FC<{ options: ICubeOptions }> = ({ options, children }) => {\r\n  return <G opacity={options.cubeOpacity / 100} strokeWidth={0.1} strokeLinejoin=\"round\" children={children} />\r\n}\r\n\r\nconst OllLayerGroup: FC<{ options: ICubeOptions }> = ({ options, children }) => {\r\n  return (\r\n    <G\r\n      opacity={options.stickerOpacity / 100}\r\n      strokeOpacity={1}\r\n      strokeWidth={0.02}\r\n      strokeLinejoin=\"round\"\r\n      children={children}\r\n    />\r\n  )\r\n}\r\n\r\nconst ArrowGroup: FC<{ cubeSize: number }> = ({ cubeSize, children }) => {\r\n  return <G opacity={1} strokeOpacity={1} strokeWidth={0.12 / cubeSize} strokeLinecap=\"round\" children={children} />\r\n}\r\n\r\nconst CubeOutline: FC<{ face: FaceStickers; options: ICubeOptions }> = ({ face, options }) => {\r\n  const cubeSize = face.length - 1\r\n  const width = options.outlineWidth\r\n  let outlinePoints = [\r\n    [face[0][0][0] * width, face[0][0][1] * width],\r\n    [face[cubeSize][0][0] * width, face[cubeSize][0][1] * width],\r\n    [face[cubeSize][cubeSize][0] * width, face[cubeSize][cubeSize][1] * width],\r\n    [face[0][cubeSize][0] * width, face[0][cubeSize][1] * width],\r\n  ]\r\n\r\n  return <Polygon fill={options.cubeColor} stroke={options.cubeColor} points={polygonPoints(outlinePoints)} />\r\n}\r\n\r\nexport const FaceStickersSvg: FC<{ face: Face; stickers: FaceStickers; options: ICubeOptions }> = ({\r\n  face,\r\n  stickers,\r\n  options,\r\n}) => {\r\n  const cubeSize = stickers.length - 1\r\n\r\n  const stickerElements: JSX.Element[] = []\r\n\r\n  for (let i = 0; i < cubeSize; i++) {\r\n    for (let j = 0; j < cubeSize; j++) {\r\n      let centerPoint: Vec3 = [\r\n        (stickers[j][i][0] + stickers[j + 1][i + 1][0]) / 2,\r\n        (stickers[j][i][1] + stickers[j + 1][i + 1][1]) / 2,\r\n        0,\r\n      ]\r\n\r\n      // Scale points in towards centre\r\n      let p1 = transScale(stickers[j][i], centerPoint, 0.85)\r\n      let p2 = transScale(stickers[j + 1][i], centerPoint, 0.85)\r\n      let p3 = transScale(stickers[j + 1][i + 1], centerPoint, 0.85)\r\n      let p4 = transScale(stickers[j][i + 1], centerPoint, 0.85)\r\n\r\n      let color = getStickerColor(face, i, j, options)\r\n      if (color !== ColorName.Transparent) {\r\n        stickerElements.push(\r\n          <Sticker key={`${i},${j}`} {...{ p1, p2, p3, p4 }} stickerColor={color} cubeColor={options.cubeColor} />\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  return (\r\n    <G\r\n      opacity={options.stickerOpacity / 100}\r\n      strokeOpacity={0.5}\r\n      strokeWidth={options.strokeWidth}\r\n      strokeLinejoin=\"round\"\r\n      children={stickerElements}\r\n    />\r\n  )\r\n}\r\n\r\nconst Sticker: ComponentType<{\r\n  p1: Vec3\r\n  p2: Vec3\r\n  p3: Vec3\r\n  p4: Vec3\r\n  stickerColor: string\r\n  cubeColor: string\r\n}> = props => {\r\n  const { p1, p2, p3, p4, stickerColor, cubeColor } = props\r\n  let stickerPoints = [[p1[0], p1[1]], [p2[0], p2[1]], [p3[0], p3[1]], [p4[0], p4[1]]]\r\n\r\n  return <Polygon fill={stickerColor} stroke={cubeColor} points={polygonPoints(stickerPoints)} />\r\n}\r\n\r\n/**\r\n * Starting with U, stickers are numbered from\r\n * their face starting with the top left corner\r\n * sticker.\r\n *\r\n * U Face\r\n * 1 | 2 | 3\r\n * ----------\r\n * 4 | 5 | 6\r\n * ----------\r\n * 7 | 8 | 9\r\n *\r\n * And so on for faces R, F, D, L, B.\r\n * So R's top left corner for a 3x3 cube would be # 10\r\n *\r\n * An individual sticker's color is obtained by indexing\r\n * into the array of sticker colors by the number the sticker is\r\n */\r\nfunction getStickerColor(face: Face, row: number, col: number, options: ICubeOptions): string {\r\n  const faceIndex = AllFaces.indexOf(face)\r\n  const stickerNumber = row * options.cubeSize + col\r\n  const colorIndex = faceIndex * (options.cubeSize * options.cubeSize) + stickerNumber\r\n\r\n  if (!Array.isArray(options.facelets) && Array.isArray(options.stickerColors)) {\r\n    if (options.stickerColors.length <= colorIndex) {\r\n      return ColorName.Black\r\n    }\r\n\r\n    return options.stickerColors[colorIndex]\r\n  } else if (Array.isArray(options.facelets)) {\r\n    if (options.facelets.length <= colorIndex) {\r\n      return ColorCode.DarkGray\r\n    }\r\n\r\n    let fd = options.facelets[colorIndex]\r\n    if (FaceletToFace[fd] != null) {\r\n      const face = FaceletToFace[fd]\r\n      return options.colorScheme[face]\r\n    }\r\n\r\n    return FaceletToColor[fd] || ColorCode.DarkGray\r\n  } else {\r\n    return options.colorScheme[face] || ColorName.Black\r\n  }\r\n}\r\n\r\n// Renders the top rim of the R U L and B faces out from side of cube\r\nexport const OLLStickers: FC<{\r\n  face: Face\r\n  stickers: FaceStickers\r\n  rotations: FaceRotations\r\n  options: ICubeOptions\r\n}> = props => {\r\n  const { face, stickers, rotations, options } = props\r\n\r\n  const stickerElements = []\r\n\r\n  // Translation vector, to move faces out\r\n  let v1 = scale(rotations[face], 0)\r\n  let v2 = scale(rotations[face], 0.2)\r\n  for (let i = 0; i < options.cubeSize; i++) {\r\n    // find center point of sticker\r\n    const centerPoint: Vec3 = [\r\n      (stickers[i][0][0] + stickers[i + 1][1][0]) / 2,\r\n      (stickers[i][0][1] + stickers[i + 1][1][1]) / 2,\r\n      0,\r\n    ]\r\n    let p1 = translate(transScale(stickers[i][0], centerPoint, 0.94), v1)\r\n    let p2 = translate(transScale(stickers[i + 1][0], centerPoint, 0.94), v1)\r\n    let p3 = translate(transScale(stickers[i + 1][1], centerPoint, 0.94), v2)\r\n    let p4 = translate(transScale(stickers[i][1], centerPoint, 0.94), v2)\r\n\r\n    let stickerColor = getStickerColor(face, 0, i, options)\r\n\r\n    if (stickerColor !== ColorName.Transparent) {\r\n      stickerElements.push(<Sticker key={i} {...{ p1, p2, p3, p4, stickerColor }} cubeColor={options.cubeColor} />)\r\n    }\r\n  }\r\n\r\n  return <Fragment>{stickerElements}</Fragment>\r\n}\r\n\r\n/**\r\n * Generates svg for an arrow pointing from sticker s1 to s2\r\n */\r\nexport const ArrowSvg: FC<{ geometry: CubeGeometry; arrow: Arrow }> = ({ geometry, arrow }) => {\r\n  let cubeSize = geometry[0].length - 1\r\n\r\n  // Find center point for each facelet\r\n  let p1y = Math.floor(arrow.s1.n / cubeSize)\r\n  let p1x = arrow.s1.n % cubeSize\r\n  let p1: Vec3 = [\r\n    (geometry[arrow.s1.face][p1x][p1y][0] + geometry[arrow.s1.face][p1x + 1][p1y + 1][0]) / 2,\r\n    (geometry[arrow.s1.face][p1x][p1y][1] + geometry[arrow.s1.face][p1x + 1][p1y + 1][1]) / 2,\r\n    0,\r\n  ]\r\n\r\n  let p2y = Math.floor(arrow.s2.n / cubeSize)\r\n  let p2x = arrow.s2.n % cubeSize\r\n  let p2: Vec3 = [\r\n    (geometry[arrow.s1.face][p2x][p2y][0] + geometry[arrow.s1.face][p2x + 1][p2y + 1][0]) / 2,\r\n    (geometry[arrow.s1.face][p2x][p2y][1] + geometry[arrow.s1.face][p2x + 1][p2y + 1][1]) / 2,\r\n    0,\r\n  ]\r\n\r\n  // Find midpoint between p1 and p2\r\n  let center: Vec3 = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2, 0]\r\n\r\n  // Shorten arrows towards midpoint according to config\r\n  p1 = transScale(p1, center, arrow.scale / 10)\r\n  p2 = transScale(p2, center, arrow.scale / 10)\r\n\r\n  let p3: Vec3\r\n  if (arrow.s3) {\r\n    let p3y = Math.floor(arrow.s3.n / cubeSize)\r\n    let p3x = arrow.s3.n % cubeSize\r\n    p3 = [\r\n      (geometry[arrow.s1.face][p3x][p3y][0] + geometry[arrow.s1.face][p3x + 1][p3y + 1][0]) / 2,\r\n      (geometry[arrow.s1.face][p3x][p3y][1] + geometry[arrow.s1.face][p3x + 1][p3y + 1][1]) / 2,\r\n      0,\r\n    ]\r\n    p3 = transScale(p3, center, arrow.influence / 5)\r\n  }\r\n\r\n  // Calculate arrow rotation\r\n  let p_ = p3 ? p3 : p1\r\n  let rotation = p_[1] > p2[1] ? 270 : 90\r\n  if (p2[0] - p_[0] != 0) {\r\n    rotation = radians2Degrees(Math.atan((p2[1] - p_[1]) / (p2[0] - p_[0])))\r\n    rotation = p_[0] > p2[0] ? rotation + 180 : rotation\r\n  }\r\n\r\n  // Draw line\r\n  let lineSvg = (\r\n    <Path\r\n      d={`M ${p1[0]},${p1[1]} ${p3 ? 'Q ' + p3[0] + ',' + p3[1] : 'L'} ${p2[0]},${p2[1]}`}\r\n      fill=\"none\"\r\n      stroke={arrow.color}\r\n      strokeOpacity={1}\r\n    />\r\n  )\r\n\r\n  // Draw arrow head\r\n  let headSvg = (\r\n    <Path\r\n      d=\"M 5.77,0.0 L -2.88,5.0 L -2.88,-5.0 L 5.77,0.0 z\"\r\n      translate={[p2[0], p2[1]]}\r\n      scale={0.033 / cubeSize}\r\n      rotation={rotation}\r\n      fill={arrow.color}\r\n      strokeWidth={0}\r\n      strokeLinejoin=\"round\"\r\n    />\r\n  )\r\n\r\n  return (\r\n    <Fragment>\r\n      {lineSvg}\r\n      {headSvg}\r\n    </Fragment>\r\n  )\r\n}\r\n\r\nexport const Cube: FC<{ geometry: CubeGeometry; options: ICubeOptions }> = ({ geometry, options }) => {\r\n  let faceRotations = rotateFaces(defaultFaceRotations, options.viewportRotations)\r\n  let renderOrder = getRenderOrder(faceRotations)\r\n\r\n  let hiddenFaces = renderOrder.filter(face => !faceVisible(face, faceRotations))\r\n  let visibleFaces = renderOrder.filter(face => faceVisible(face, faceRotations))\r\n\r\n  let arrowDefinitions: Arrow[] = []\r\n\r\n  if (Array.isArray(options.arrows)) {\r\n    arrowDefinitions = options.arrows\r\n  } else if (typeof options.arrows === 'string') {\r\n    arrowDefinitions = parseArrows(options.arrows)\r\n  }\r\n\r\n  return (\r\n    <Svg\r\n      width={options.width}\r\n      height={options.height}\r\n      viewBox={viewBox(options.viewbox.x, options.viewbox.y, options.viewbox.width, options.viewbox.height)}\r\n    >\r\n      <Background options={options} />\r\n      {options.cubeOpacity < 100 && (\r\n        <Fragment>\r\n          <CubeOutlineGroup options={options}>\r\n            {hiddenFaces.map((face, index) => (\r\n              <CubeOutline key={index} face={geometry[face]} options={options} />\r\n            ))}\r\n          </CubeOutlineGroup>\r\n          {hiddenFaces.map((face, index) => (\r\n            <FaceStickersSvg key={index} face={face} stickers={geometry[face]} options={options} />\r\n          ))}\r\n        </Fragment>\r\n      )}\r\n\r\n      <CubeOutlineGroup options={options}>\r\n        {visibleFaces.map((face, index) => (\r\n          <CubeOutline key={index} face={geometry[face]} options={options} />\r\n        ))}\r\n      </CubeOutlineGroup>\r\n\r\n      {visibleFaces.map((face, index) => (\r\n        <FaceStickersSvg key={index} face={face} stickers={geometry[face]} options={options} />\r\n      ))}\r\n\r\n      {options.view === 'plan' && (\r\n        <OllLayerGroup options={options}>\r\n          {[Face.R, Face.F, Face.L, Face.B].map((face, index) => (\r\n            <OLLStickers key={index} face={face} stickers={geometry[face]} rotations={faceRotations} options={options} />\r\n          ))}\r\n        </OllLayerGroup>\r\n      )}\r\n\r\n      <ArrowGroup cubeSize={geometry[0].length - 1}>\r\n        {arrowDefinitions.map((arrow, index) => (\r\n          <ArrowSvg key={index} geometry={geometry} arrow={arrow} />\r\n        ))}\r\n      </ArrowGroup>\r\n    </Svg>\r\n  )\r\n}\r\n","import { Axis } from './../math'\r\nimport { AllFaces, Face, AlgorithmUnit } from './constants'\r\nimport { Turn } from './parsing/algorithm'\r\n\r\nexport enum TurnType {\r\n  Clockwise,\r\n  CounterClockwise,\r\n  Double,\r\n}\r\n\r\n// Given sticker N return sticker number after rotation\r\ntype FaceRotation = (stickerNumber: number, cubeSize: number) => number\r\n\r\nconst faceIdentity: FaceRotation = (stickerNumber: number, cubeSize: number) => stickerNumber\r\nconst counterClockwiseSticker: FaceRotation = (stickerNumber, cubeSize) =>\r\n  (stickerNumber * cubeSize) % (cubeSize * cubeSize + 1)\r\nconst clockwiseSticker: FaceRotation = (stickerNumber, cubeSize) => {\r\n  let numStickers = cubeSize * cubeSize\r\n  return numStickers + 1 - counterClockwiseSticker(stickerNumber, cubeSize)\r\n}\r\nconst doubleTurn: FaceRotation = (stickerNumber, cubeSize) => {\r\n  return cubeSize * cubeSize - stickerNumber + 1\r\n}\r\n\r\nconst OppositeTurn = {\r\n  [TurnType.Clockwise]: TurnType.CounterClockwise,\r\n  [TurnType.CounterClockwise]: TurnType.Clockwise,\r\n  [TurnType.Double]: TurnType.Double,\r\n}\r\n\r\n// Faces that wrap around a given axis\r\nconst AxisMapping = {\r\n  [Axis.X]: [Face.U, Face.B, Face.F, Face.D],\r\n  [Axis.Y]: [Face.L, Face.B, Face.R, Face.F],\r\n  [Axis.Z]: [Face.L, Face.U, Face.R, Face.D],\r\n}\r\n\r\n// Face's orientation related to other faces on a given axis\r\nconst AxisOrientation: { [axis: number]: { [face: number]: FaceRotation } } = {\r\n  [Axis.X]: {\r\n    [Face.U]: faceIdentity,\r\n    [Face.B]: doubleTurn,\r\n    [Face.F]: faceIdentity,\r\n    [Face.D]: faceIdentity,\r\n    [Face.L]: null,\r\n    [Face.R]: null,\r\n  },\r\n  [Axis.Y]: {\r\n    [Face.U]: null,\r\n    [Face.B]: counterClockwiseSticker,\r\n    [Face.F]: counterClockwiseSticker,\r\n    [Face.D]: null,\r\n    [Face.L]: counterClockwiseSticker,\r\n    [Face.R]: counterClockwiseSticker,\r\n  },\r\n  [Axis.Z]: {\r\n    [Face.U]: counterClockwiseSticker,\r\n    [Face.B]: null,\r\n    [Face.F]: null,\r\n    [Face.D]: clockwiseSticker,\r\n    [Face.L]: faceIdentity,\r\n    [Face.R]: doubleTurn,\r\n  },\r\n}\r\n\r\nexport class CubeData {\r\n  /**\r\n   *  Data to store face value\r\n   *  data saved in flat array [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n   *  maps to cube stickers like this\r\n   *\r\n   *  U Face\r\n   *  1 | 2 | 3\r\n   *  ----------\r\n   *  4 | 5 | 6\r\n   *  ----------\r\n   *  7 | 8 | 9\r\n   *\r\n   *  Stickers are numbered in that manner starting with the U face\r\n   *  continuing with this order U, R, F, D, L, B\r\n   *\r\n   *  Because each face has a differen't orientation it may not be clear\r\n   *  how the back faces are numbered. Below is an example 3x3 mapping\r\n   *\r\n   *  Example numbers of 3x3 cube. nxn cubes follow the same pattern\r\n   *\r\n   *        B\r\n   *      L U R\r\n   *        F\r\n   *        D\r\n   *                  | 54  | 53  | 52  |\r\n   *                   -----------------\r\n   *                  | 51  | 50  | 49  |\r\n   *                   -----------------\r\n   *                  | 48  | 47  | 46  |\r\n   * -----------------                   -----------------\r\n   *  43  | 40  | 37     1  |  2  |  3    12  | 15  | 18\r\n   * ----------------- ----------------- -----------------\r\n   *  44  | 41  | 38     4  |  5  |  6    11  | 14  | 17\r\n   * ----------------- ----------------- -----------------\r\n   *  45  | 42  | 39     7  |  8  |  9    10  | 13  | 16\r\n   * -----------------                   -----------------\r\n   *                  | 19  | 20  | 21  |\r\n   *                   -----------------\r\n   *                  | 22  | 23  | 24  |\r\n   *                   -----------------\r\n   *                  | 25  | 26  | 27  |\r\n   *\r\n   *                  | 28  | 29  | 30  |\r\n   *                   -----------------\r\n   *                  | 31  | 32  | 33  |\r\n   *                   -----------------\r\n   *                  | 34  | 35  | 36  |\r\n   */\r\n  public faces: { [face: number]: any[] } = {}\r\n  private numStickers: number\r\n\r\n  // Precalculated index mapping values for face rotations\r\n  private clockwiseMapping: number[]\r\n  private counterClockwiseMapping: number[]\r\n  private doubleMapping: number[]\r\n\r\n  constructor(private cubeSize: number, initialValues?: { [face: number]: any[] }) {\r\n    this.numStickers = this.cubeSize * this.cubeSize\r\n    this.clockwiseMapping = []\r\n    this.counterClockwiseMapping = []\r\n    this.doubleMapping = []\r\n\r\n    this.faces = initialValues\r\n\r\n    if (!this.faces) {\r\n      this.initValues()\r\n    }\r\n\r\n    for (let i = 1; i <= this.numStickers; i++) {\r\n      this.clockwiseMapping.push(clockwiseSticker(i, cubeSize))\r\n      this.counterClockwiseMapping.push(counterClockwiseSticker(i, cubeSize))\r\n      this.doubleMapping.push(doubleTurn(i, cubeSize))\r\n    }\r\n  }\r\n\r\n  private initValues() {\r\n    let currentValue = 1\r\n    AllFaces.forEach(face => {\r\n      this.faces[face] = []\r\n      for (let i = 0; i < this.numStickers; i++) {\r\n        this.faces[face].push(currentValue++)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Rotates values on an outer face of the rubiks cubes\r\n   */\r\n  private rotateFace(face: Face, turn: TurnType) {\r\n    // TODO more efficient rotation to not construct so many new arrays\r\n    switch (turn) {\r\n      case TurnType.Clockwise:\r\n        this.faces[face] = this.clockwiseMapping.map(newStickerNumber => this.faces[face][newStickerNumber - 1])\r\n        break\r\n      case TurnType.CounterClockwise:\r\n        this.faces[face] = this.counterClockwiseMapping.map(newStickerNumber => this.faces[face][newStickerNumber - 1])\r\n        break\r\n      case TurnType.Double:\r\n        this.faces[face].reverse()\r\n        break\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rotates layer values around a given axis\r\n   */\r\n  private axisRotation(\r\n    offset: number,\r\n    range: number,\r\n    axis: Axis,\r\n    faceOrder: Face[],\r\n    forward: boolean = true,\r\n    double: boolean = false\r\n  ) {\r\n    if (!forward) {\r\n      faceOrder.reverse()\r\n    }\r\n\r\n    // Copy original values to avoid clobbering values when modifying stickers\r\n    let originalValues = faceOrder.map(face => this.faces[face].slice())\r\n\r\n    // Copy values\r\n    for (let i = 0; i < this.cubeSize; i++) {\r\n      for (let r = 0; r < range; r++) {\r\n        const stickerIndex = this.cubeSize * i + (offset + r)\r\n        for (let j = 0; j < faceOrder.length; j++) {\r\n          const face = faceOrder[j]\r\n          const nextFace = double ? faceOrder[(j + 2) % faceOrder.length] : faceOrder[(j + 1) % faceOrder.length]\r\n          const valueIndex = AxisOrientation[axis][face](stickerIndex + 1, this.cubeSize) - 1\r\n          const nextFaceValueIndex = AxisOrientation[axis][nextFace](stickerIndex + 1, this.cubeSize) - 1\r\n          this.faces[face][valueIndex] =\r\n            originalValues[(double ? j + 2 : j + 1) % originalValues.length][nextFaceValueIndex]\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rotate layers around the x axis of the cube\r\n   */\r\n  private xLayersRotation(offset: number, forward: boolean = true, double: boolean = false, range: number = 1) {\r\n    let faceOrder = [Face.U, Face.F, Face.D, Face.B]\r\n    this.axisRotation(offset, range, Axis.X, faceOrder, forward, double)\r\n  }\r\n\r\n  /**\r\n   * Rotate layers around the y axis of the cube\r\n   */\r\n  private yLayersRotation(offset: number, forward: boolean = true, double: boolean = false, range: number = 1) {\r\n    let faceOrder = [Face.L, Face.F, Face.R, Face.B]\r\n    this.axisRotation(offset, range, Axis.Y, faceOrder, forward, double)\r\n  }\r\n\r\n  /**\r\n   * Rotate layers around the z axis of the cube\r\n   */\r\n  private zLayersRotation(offset: number, forward: boolean = true, double: boolean = false, range: number = 1) {\r\n    let faceOrder = [Face.U, Face.L, Face.D, Face.R]\r\n    this.axisRotation(offset, range, Axis.Z, faceOrder, forward, double)\r\n  }\r\n\r\n  /**\r\n   * Restricts the number of slices used in outer block moves to the cube size\r\n   */\r\n  private safeSlices(n: number): number {\r\n    return n > this.cubeSize ? this.cubeSize : n\r\n  }\r\n\r\n  rTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.R, turnType)\r\n    let offset = this.cubeSize - slices\r\n    this.xLayersRotation(offset, turnType === TurnType.Clockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  lTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.L, turnType)\r\n    this.xLayersRotation(0, turnType === TurnType.CounterClockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  uTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.U, turnType)\r\n    this.yLayersRotation(0, turnType === TurnType.Clockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  dTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.D, turnType)\r\n    let offset = this.cubeSize - slices\r\n    this.yLayersRotation(offset, turnType === TurnType.CounterClockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  fTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.F, turnType)\r\n    let offset = this.cubeSize - slices\r\n    this.zLayersRotation(offset, turnType === TurnType.Clockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  bTurn(turnType: TurnType, slices: number = 1) {\r\n    this.rotateFace(Face.B, turnType)\r\n    this.zLayersRotation(0, turnType === TurnType.CounterClockwise, turnType === TurnType.Double, slices)\r\n  }\r\n\r\n  mTurn(turnType: TurnType) {\r\n    if (this.cubeSize < 2) return\r\n    this.xLayersRotation(1, turnType === TurnType.CounterClockwise, turnType === TurnType.Double, this.cubeSize - 2)\r\n  }\r\n\r\n  eTurn(turnType: TurnType) {\r\n    if (this.cubeSize < 2) return\r\n    this.yLayersRotation(1, turnType === TurnType.CounterClockwise, turnType === TurnType.Double, this.cubeSize - 2)\r\n  }\r\n\r\n  sTurn(turnType: TurnType) {\r\n    if (this.cubeSize < 2) return\r\n    this.zLayersRotation(1, turnType === TurnType.Clockwise, turnType === TurnType.Double, this.cubeSize - 2)\r\n  }\r\n\r\n  xTurn(turnType: TurnType) {\r\n    this.rotateFace(Face.R, turnType)\r\n    this.rotateFace(Face.L, OppositeTurn[turnType])\r\n    this.xLayersRotation(0, turnType === TurnType.Clockwise, turnType === TurnType.Double, this.cubeSize)\r\n  }\r\n\r\n  yTurn(turnType: TurnType) {\r\n    this.rotateFace(Face.U, turnType)\r\n    this.rotateFace(Face.D, OppositeTurn[turnType])\r\n    this.yLayersRotation(0, turnType === TurnType.Clockwise, turnType === TurnType.Double, this.cubeSize)\r\n  }\r\n\r\n  zTurn(turnType: TurnType) {\r\n    this.rotateFace(Face.F, turnType)\r\n    this.rotateFace(Face.B, OppositeTurn[turnType])\r\n    this.zLayersRotation(0, turnType === TurnType.Clockwise, turnType === TurnType.Double, this.cubeSize)\r\n  }\r\n\r\n  turn(turn: Turn) {\r\n    let slices = this.safeSlices(turn.slices)\r\n    switch (turn.move) {\r\n      case AlgorithmUnit.F:\r\n        this.fTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.B:\r\n        this.bTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.U:\r\n        this.uTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.D:\r\n        this.dTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.R:\r\n        this.rTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.L:\r\n        this.lTurn(turn.turnType, slices)\r\n        break\r\n      case AlgorithmUnit.M:\r\n        this.mTurn(turn.turnType)\r\n        break\r\n      case AlgorithmUnit.E:\r\n        this.eTurn(turn.turnType)\r\n        break\r\n      case AlgorithmUnit.S:\r\n        this.sTurn(turn.turnType)\r\n        break\r\n      case AlgorithmUnit.X:\r\n        this.xTurn(turn.turnType)\r\n        break\r\n      case AlgorithmUnit.Y:\r\n        this.yTurn(turn.turnType)\r\n        break\r\n      case AlgorithmUnit.Z:\r\n        this.zTurn(turn.turnType)\r\n        break\r\n      default:\r\n        throw new Error(`Unrecognized move in turn ${JSON.stringify(turn)}`)\r\n    }\r\n  }\r\n}\r\n","import { StickerDefinition } from '../models/sticker'\r\nimport { Arrow } from '../models/arrow'\r\nimport { Face } from '../constants'\r\nimport { ColorCode, ColorName } from '../../constants'\r\nimport { parseColor } from './color'\r\n\r\nconst stickerPattern = '([URFDLB])([0-9]+)'\r\nconst colorPattern =\r\n  '(black|dgrey|grey|silver|white|yellow|red|orange|blue|green|purple|pink|[0-9a-fA-F]{6}|[0-9a-fA-F]{3})'\r\nconst arrowPattern = `^(${stickerPattern})(${stickerPattern})(${stickerPattern})?(-s([0-9+]))?(-i([0-9+]))?(-${colorPattern})?`\r\n\r\nexport function parseArrows(raw: string): Arrow[] {\r\n  if (typeof raw !== 'string') {\r\n    return []\r\n  }\r\n\r\n  return raw\r\n    .split(',')\r\n    .map(part => parseArrow(part))\r\n    .filter(arrow => !!arrow)\r\n}\r\n\r\nexport function parseArrow(raw: string): Arrow {\r\n  if (typeof raw !== 'string') {\r\n    return null\r\n  }\r\n\r\n  let arrowRegex = new RegExp(arrowPattern)\r\n  let match = arrowRegex.exec(raw)\r\n\r\n  if (!match) {\r\n    return null\r\n  }\r\n\r\n  return <Arrow>{\r\n    s1: {\r\n      face: Face[match[2]],\r\n      n: parseInt(match[3]),\r\n    },\r\n    s2: {\r\n      face: Face[match[5]],\r\n      n: parseInt(match[6]),\r\n    },\r\n    s3: !match[7]\r\n      ? undefined\r\n      : {\r\n          face: Face[match[8]],\r\n          n: parseInt(match[9]),\r\n        },\r\n    color: match[15] ? parseColor(match[15]) : ColorCode.Gray,\r\n    scale: match[11] ? parseInt(match[11]) : 10,\r\n    influence: match[13] ? parseInt(match[13]) : 10,\r\n  }\r\n}\r\n","import { Masking, Face, AllFaces } from './constants'\r\n\r\ntype FaceValues = { [face: number]: any[] }\r\ntype MaskingFunctions = {\r\n  [masking: string]: {\r\n    [face: number]: (row: number, col: number, cubeSize: number) => boolean\r\n  }\r\n}\r\n\r\nconst maskingFunctions: MaskingFunctions = {\r\n  [Masking.FL]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row == cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row == cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row == cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row == cubeSize - 1,\r\n  },\r\n  [Masking.F2L]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.LL]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => row == 0,\r\n    [Face.L]: (row, col, cubeSize) => row == 0,\r\n    [Face.F]: (row, col, cubeSize) => row == 0,\r\n    [Face.B]: (row, col, cubeSize) => row == 0,\r\n  },\r\n  [Masking.CLL]: {\r\n    [Face.U]: (row, col, cubeSize) =>\r\n      (row > 0 && col > 0 && row < cubeSize - 1 && col < cubeSize - 1) || // is center\r\n      ((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.L]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.F]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.B]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n  },\r\n  [Masking.ELL]: {\r\n    [Face.U]: (row, col, cubeSize) => !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n  },\r\n  [Masking.OLL]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => false,\r\n    [Face.L]: (row, col, cubeSize) => false,\r\n    [Face.F]: (row, col, cubeSize) => false,\r\n    [Face.B]: (row, col, cubeSize) => false,\r\n  },\r\n  [Masking.OCLL]: {\r\n    [Face.U]: (row, col, cubeSize) =>\r\n      (row > 0 && col > 0 && row < cubeSize - 1 && col < cubeSize - 1) || // is center\r\n      ((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => false,\r\n    [Face.L]: (row, col, cubeSize) => false,\r\n    [Face.F]: (row, col, cubeSize) => false,\r\n    [Face.B]: (row, col, cubeSize) => false,\r\n  },\r\n  [Masking.OELL]: {\r\n    [Face.U]: (row, col, cubeSize) => !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => false,\r\n    [Face.L]: (row, col, cubeSize) => false,\r\n    [Face.F]: (row, col, cubeSize) => false,\r\n    [Face.B]: (row, col, cubeSize) => false,\r\n  },\r\n  [Masking.COLL]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.L]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.F]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.B]: (row, col, cubeSize) => row == 0 && (col == 0 || col == cubeSize - 1),\r\n  },\r\n  [Masking.OCELL]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => false,\r\n    [Face.R]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row == 0 && col > 0 && col < cubeSize - 1,\r\n  },\r\n  [Masking.WV]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.VH]: {\r\n    [Face.U]: (row, col, cubeSize) => !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.ELS]: {\r\n    [Face.U]: (row, col, cubeSize) => !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.D]: (row, col, cubeSize) => (row == 0 ? col < cubeSize - 1 : true),\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && (row == cubeSize - 1 ? col > 0 : true),\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && (row == cubeSize - 1 ? col < cubeSize - 1 : true),\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.CLS]: {\r\n    [Face.U]: (row, col, cubeSize) => true,\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.CMLL]: {\r\n    [Face.U]: (row, col, cubeSize) => (row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1),\r\n    [Face.D]: (row, col, cubeSize) => true,\r\n    [Face.R]: (row, col, cubeSize) => row > 0 || col == 0 || col == cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row > 0 || col == 0 || col == cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => col == 0 || col == cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => col == 0 || col == cubeSize - 1,\r\n  },\r\n  [Masking.CROSS]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n  },\r\n  [Masking.F2L3]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) =>\r\n      (row == 0 && col == cubeSize - 1) || !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)),\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && col < cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n  },\r\n  [Masking.F2L2]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => row > 0 || (col > 0 && col < cubeSize - 1),\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && col > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.F2LSM]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) =>\r\n      !((row == 0 || row == cubeSize - 1) && (col == 0 || col == cubeSize - 1)) ||\r\n      (col == 0 && row == cubeSize - 1) ||\r\n      (row == 0 && col == cubeSize - 1),\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && col < cubeSize - 1,\r\n    [Face.L]: (row, col, cubeSize) => row > 0 && col < cubeSize - 1,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col > 0,\r\n    [Face.B]: (row, col, cubeSize) => row > 0 && col > 0,\r\n  },\r\n  [Masking.F2L1]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => row !== 0 || col !== cubeSize - 1,\r\n    [Face.R]: (row, col, cubeSize) => row > 0 && col > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row > 0,\r\n  },\r\n  [Masking.F2B]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => col == 0 || col == cubeSize - 1,\r\n    [Face.R]: (row, col, cubeSize) => row > 0,\r\n    [Face.L]: (row, col, cubeSize) => row > 0,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && (col == 0 || col == cubeSize - 1),\r\n    [Face.B]: (row, col, cubeSize) => row > 0 && (col == 0 || col == cubeSize - 1),\r\n  },\r\n  [Masking.LINE]: {\r\n    [Face.U]: (row, col, cubeSize) => false,\r\n    [Face.D]: (row, col, cubeSize) => col > 0 && col < cubeSize - 1,\r\n    [Face.R]: (row, col, cubeSize) => false,\r\n    [Face.L]: (row, col, cubeSize) => false,\r\n    [Face.F]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n    [Face.B]: (row, col, cubeSize) => row > 0 && col > 0 && col < cubeSize - 1,\r\n  },\r\n}\r\n\r\nexport function makeMasking(masking: Masking, cubeSize: number): FaceValues {\r\n  if (!maskingFunctions[masking]) {\r\n    throw new Error(`invalid masking ${masking}`)\r\n  }\r\n\r\n  let numStickers = cubeSize * cubeSize\r\n  let faceValues = {\r\n    [Face.U]: [],\r\n    [Face.F]: [],\r\n    [Face.R]: [],\r\n    [Face.D]: [],\r\n    [Face.L]: [],\r\n    [Face.B]: [],\r\n  }\r\n\r\n  for (let i = 0; i < numStickers; i++) {\r\n    let row = Math.floor(i / cubeSize)\r\n    let col = i % cubeSize\r\n\r\n    AllFaces.forEach(face => {\r\n      faceValues[face].push(maskingFunctions[masking][face](row, col, cubeSize))\r\n    })\r\n  }\r\n\r\n  return faceValues\r\n}\r\n","import { cubeRotations } from './../constants'\r\nimport { TurnType } from '../simulation'\r\nimport { TurnAbbreviation, AlgorithmUnit, possibleMoves } from '../constants'\r\n\r\nexport interface Turn {\r\n  move: AlgorithmUnit\r\n  turnType: TurnType\r\n  slices: number\r\n}\r\n\r\nconst turnRegex = /([2-9]+)?([UuFfRrDdLlBbMESxyz])(w)?([2\\'])?/g\r\n\r\nconst Opposite = {\r\n  [TurnType.Clockwise]: TurnType.CounterClockwise,\r\n  [TurnType.CounterClockwise]: TurnType.Clockwise,\r\n  [TurnType.Double]: TurnType.Double,\r\n}\r\n\r\n/**\r\n * Takes in an algorithm string and parses the turns from it\r\n * algorithm string format should be moves separated by a single space\r\n * (ex. \"U R2 L' x\")\r\n *\r\n * https://www.worldcubeassociation.org/regulations/#article-12-notation\r\n */\r\nexport function parseAlgorithm(algorithm: string): Turn[] {\r\n  if (!algorithm) {\r\n    return []\r\n  }\r\n  let turns: Turn[] = []\r\n  let match\r\n  do {\r\n    match = turnRegex.exec(algorithm)\r\n    if (match) {\r\n      let rawSlices: string = match[1]\r\n      let rawFace: string = match[2]\r\n      let outerBlockIndicator = match[3]\r\n      let rawType = match[4] || TurnAbbreviation.Clockwise // Default to clockwise\r\n      let isLowerCaseMove = rawFace === rawFace.toLowerCase() && cubeRotations.indexOf(rawFace) === -1\r\n\r\n      if (isLowerCaseMove) {\r\n        rawFace = rawFace.toUpperCase()\r\n      }\r\n\r\n      let turn: Turn = {\r\n        move: getMove(rawFace),\r\n        turnType: getTurnType(rawType),\r\n        slices: isLowerCaseMove ? 2 : getSlices(rawSlices, outerBlockIndicator),\r\n      }\r\n\r\n      turns.push(turn)\r\n    }\r\n  } while (match)\r\n\r\n  return turns\r\n}\r\n\r\nexport function parseCase(algorithm: string): Turn[] {\r\n  return parseAlgorithm(algorithm)\r\n    .map(turn => {\r\n      return <Turn>{\r\n        turnType: Opposite[turn.turnType],\r\n        move: turn.move,\r\n        slices: turn.slices,\r\n      }\r\n    })\r\n    .reverse()\r\n}\r\n\r\nfunction getSlices(rawSlices, outerBlockIndicator): number {\r\n  if (outerBlockIndicator && !rawSlices) {\r\n    return 2\r\n  } else if (!outerBlockIndicator && rawSlices) {\r\n    throw new Error(`Invalid move: Cannot specify num slices if outer block move indicator 'w' is not present`)\r\n  } else if (!outerBlockIndicator && !rawSlices) {\r\n    return 1\r\n  } else {\r\n    return parseInt(rawSlices)\r\n  }\r\n}\r\n\r\nfunction getMove(rawFace: string): AlgorithmUnit {\r\n  if (possibleMoves.indexOf(rawFace) < 0) {\r\n    throw new Error(`Invalid move (${rawFace}): Possible turn faces are [U R F L D B M E S x y z]`)\r\n  } else return rawFace as AlgorithmUnit\r\n}\r\n\r\nfunction getTurnType(rawType: string): TurnType {\r\n  switch (rawType) {\r\n    case TurnAbbreviation.Clockwise:\r\n      return TurnType.Clockwise\r\n    case TurnAbbreviation.CounterClockwise:\r\n      return TurnType.CounterClockwise\r\n    case TurnAbbreviation.Double:\r\n      return TurnType.Double\r\n    default:\r\n      throw new Error(`Invalid move modifier (${rawType})`)\r\n  }\r\n}\r\n","import { FaceletDefinition, FaceletAbbreviateToDefinition } from '../../constants'\r\n\r\nexport function parseFaceletDefinitions(rawValue: string): FaceletDefinition[] {\r\n  let colors = []\r\n  for (let i = 0; i < rawValue.length; i++) {\r\n    colors.push(FaceletAbbreviateToDefinition[rawValue.charAt(i)])\r\n  }\r\n  return colors\r\n}\r\n","import React, { FC } from 'react'\r\nimport { makeCubeGeometry } from './cube/geometry'\r\nimport { Axis } from './math'\r\nimport { Cube } from './cube/drawing';\r\nimport { ICubeOptions } from './cube/options'\r\nimport { DefaultColorScheme } from './cube/constants'\r\nimport { makeStickerColors } from './cube/stickers'\r\nimport { ColorName } from './constants'\r\nimport { parseOptions } from './cube/parsing/options'\r\nimport { parseFaceletDefinitions } from './cube/parsing/faceletDefinitions'\r\n\r\nconst defaultOptions: ICubeOptions = {\r\n  cubeSize: 3,\r\n  width: 128,\r\n  height: 128,\r\n  viewportRotations: [[Axis.Y, 45], [Axis.X, -34]],\r\n  colorScheme: DefaultColorScheme,\r\n  cubeColor: ColorName.Black,\r\n  cubeOpacity: 100,\r\n  stickerOpacity: 100,\r\n  dist: 5,\r\n  outlineWidth: 0.94,\r\n  strokeWidth: 0,\r\n  viewbox: {\r\n    x: -0.9,\r\n    y: -0.9,\r\n    width: 1.8,\r\n    height: 1.8,\r\n  },\r\n}\r\n\r\nexport const CubeSvg: FC<{extraOptions?: any}> = (props) => {\r\n  let options = getOptions(defaultOptions, props.extraOptions || {})\r\n  let geometry = makeCubeGeometry(options)\r\n  options.stickerColors = makeStickerColors(options)\r\n\r\n  return <Cube geometry={geometry} options={options} />\r\n}\r\n\r\nfunction getOptions(defaultOptions: ICubeOptions, extraOptions: string | ICubeOptions): ICubeOptions {\r\n  let parsedOptions: ICubeOptions\r\n  if (typeof extraOptions === 'string') {\r\n    parsedOptions = parseOptions(extraOptions)\r\n  } else {\r\n    parsedOptions = extraOptions\r\n  }\r\n\r\n  if (typeof parsedOptions.facelets === 'string') {\r\n    parsedOptions.facelets = parseFaceletDefinitions(parsedOptions.facelets)\r\n  }\r\n\r\n  return { ...defaultOptions, ...parsedOptions }\r\n}\r\n","import { ICubeOptions } from '../options'\r\nimport { parseRotationSequence } from './rotation'\r\nimport { parseFaceletColors } from './faceletColors'\r\nimport { parseColorScheme } from './colorScheme'\r\nimport { parseFaceletDefinitions } from './faceletDefinitions'\r\n\r\n/**\r\n * Utility methods for parsing the old query param style options\r\n */\r\n\r\nexport function parseOptions(rawOptions: string): ICubeOptions {\r\n  let options: ICubeOptions = {} as any\r\n  let params = parseQuery(rawOptions)\r\n\r\n  Object.keys(params).forEach(key => {\r\n    let paramValue = params[key]\r\n    switch (key) {\r\n      case 'pzl':\r\n        options.cubeSize = parseInt(paramValue) || 3\r\n        break\r\n      case 'size':\r\n        let size = parseInt(paramValue) || 250\r\n        options.width = size\r\n        options.height = size\r\n        break\r\n      case 'view':\r\n        options.view = paramValue\r\n        break\r\n      case 'stage':\r\n        options.mask = paramValue\r\n        break\r\n      case 'r':\r\n        options.viewportRotations = parseRotationSequence(paramValue)\r\n        break\r\n      case 'alg':\r\n        options.algorithm = paramValue\r\n        break\r\n      case 'case':\r\n        options.case = paramValue\r\n        break\r\n      case 'fc':\r\n        options.stickerColors = parseFaceletColors(paramValue)\r\n        break\r\n      case 'sch':\r\n        options.colorScheme = parseColorScheme(paramValue)\r\n        break\r\n      case 'bg':\r\n        options.backgroundColor = paramValue\r\n        break\r\n      case 'cc':\r\n        options.cubeColor = paramValue\r\n        break\r\n      case 'co':\r\n        options.cubeOpacity = parseInt(paramValue) || 100\r\n        break\r\n      case 'fo':\r\n        options.stickerOpacity = parseInt(paramValue) || 100\r\n        break\r\n      case 'dist':\r\n        options.dist = parseInt(paramValue) || 5\r\n        break\r\n      case 'arw':\r\n        options.arrows = paramValue\r\n        break\r\n      case 'fd':\r\n        options.facelets = parseFaceletDefinitions(paramValue)\r\n        break\r\n      case 'ac':\r\n        // TODO: Support default arrow color\r\n        console.warn(\"Currently param 'ac' is unsupported\")\r\n        break\r\n    }\r\n  })\r\n  return options\r\n}\r\n\r\nfunction parseQuery(url) {\r\n  let queryString = url.indexOf('?') > -1 ? url.substr(url.indexOf('?') + 1) : url\r\n  var query = {}\r\n  var pairs = queryString.split('&')\r\n  for (var i = 0; i < pairs.length; i++) {\r\n    var pair = pairs[i].split('=')\r\n    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '')\r\n  }\r\n  return query\r\n}\r\n","import { ICubeColorScheme } from '../models/color-scheme'\r\nimport { parseColor } from './color'\r\nimport { ColorCode, ColorNameToCode, ColorAbbreviationToCode } from '../../constants'\r\nimport { AllFaces, DefaultColorScheme } from '../constants'\r\n\r\nexport function parseColorScheme(rawValue: string): ICubeColorScheme {\r\n  if (rawValue.indexOf(',') > -1) {\r\n    return parseCommaSeparatedValues(rawValue)\r\n  } else {\r\n    return parseAbbreviations(rawValue)\r\n  }\r\n}\r\n\r\nfunction parseAbbreviations(rawValue) {\r\n  let scheme: ICubeColorScheme = {}\r\n  if (rawValue.length < AllFaces.length) {\r\n    return DefaultColorScheme\r\n  }\r\n\r\n  AllFaces.forEach((face, index) => {\r\n    if (rawValue.length > index) {\r\n      scheme[face] = ColorAbbreviationToCode[rawValue.charAt(index)]\r\n    }\r\n  })\r\n\r\n  return scheme\r\n}\r\n\r\nfunction parseCommaSeparatedValues(rawValue) {\r\n  let scheme: ICubeColorScheme = {}\r\n\r\n  // Parse as comma separated list of colors\r\n  let rawColors = rawValue.split(',')\r\n  if (rawColors.length < AllFaces.length) {\r\n    return DefaultColorScheme\r\n  }\r\n  AllFaces.forEach((face, index) => {\r\n    if (rawColors.length > index) {\r\n      let parsedColor = parseColor(rawColors[index])\r\n      let colorCode: ColorCode = ColorNameToCode[parsedColor] || (parsedColor as ColorCode)\r\n      if (parsedColor) {\r\n        scheme[face] = colorCode\r\n      }\r\n    }\r\n  })\r\n\r\n  return scheme\r\n}\r\n","import { Axis } from '../../math'\r\nimport { AxisSymbolToAxis } from '../constants'\r\n\r\nexport function parseRotationSequence(rawSequence: string): [Axis, number][] {\r\n  const rotationRegex = /([xyz]-?[0-9][0-9]?[0-9]?)/g\r\n  let match\r\n  let rotations: [Axis, number][] = []\r\n\r\n  do {\r\n    match = rotationRegex.exec(rawSequence)\r\n    if (match) {\r\n      let matchText: string = match[0]\r\n      let axisSymbol = matchText.charAt(0)\r\n      let value = matchText.substr(1)\r\n      let axis = AxisSymbolToAxis[axisSymbol]\r\n      rotations.push([axis, parseInt(value)])\r\n    }\r\n  } while (match)\r\n\r\n  return rotations\r\n}\r\n","import { parseColor } from './color'\r\nimport { ColorAbbreviationToCode } from '../../constants'\r\n\r\nexport function parseFaceletColors(rawValue: string): string[] {\r\n  let colors = []\r\n  if (rawValue.indexOf(',') > -1) {\r\n    // Parse as comma separated colors\r\n    rawValue.split(',').forEach(value => {\r\n      let parsed = parseColor(value)\r\n      if (parsed) {\r\n        colors.push(parsed)\r\n      }\r\n    })\r\n  } else {\r\n    // parse as abbreviations (ex 'yyyyyyyyyrrrrrrrrrbbbbbbbbb....')\r\n    for (let i = 0; i < rawValue.length; i++) {\r\n      colors.push(ColorAbbreviationToCode[rawValue.charAt(i)])\r\n    }\r\n  }\r\n  return colors\r\n}\r\n","import { ICubeOptions } from './options'\r\nimport { makeMasking } from './masking'\r\nimport { CubeData } from './simulation'\r\nimport { parseAlgorithm, parseCase, Turn } from './parsing/algorithm'\r\nimport { AllFaces } from './constants'\r\nimport { ColorName, ColorCode } from '../constants'\r\n\r\nexport function makeStickerColors(options: ICubeOptions): string[] {\r\n  let stickerColors = options.stickerColors\r\n  let mask = options.mask ? makeMasking(options.mask, options.cubeSize) : null\r\n\r\n  if (mask && options.maskAlg) {\r\n    let maskCubeData = new CubeData(options.cubeSize, mask)\r\n    let alg = parseAlgorithm(options.maskAlg)\r\n    alg.forEach(turn => {\r\n      maskCubeData.turn(turn)\r\n    })\r\n    mask = maskCubeData.faces\r\n  }\r\n\r\n  // Fill with color scheme if sticker colors not predefined.\r\n  if (!stickerColors) {\r\n    stickerColors = [].concat.apply(\r\n      [],\r\n      AllFaces.map(face => {\r\n        return Array.apply(null, Array(options.cubeSize * options.cubeSize)).map(() => options.colorScheme[face])\r\n      })\r\n    )\r\n  }\r\n\r\n  let faceMappedStickers = AllFaces.reduce((acc, face) => {\r\n    if (!acc[face]) acc[face] = []\r\n\r\n    for (let i = 0; i < options.cubeSize; i++) {\r\n      for (let j = 0; j < options.cubeSize; j++) {\r\n        const faceIndex = AllFaces.indexOf(face)\r\n        const stickerNumber = i * options.cubeSize + j\r\n        const colorIndex = faceIndex * (options.cubeSize * options.cubeSize) + stickerNumber\r\n\r\n        if (stickerColors.length <= colorIndex) {\r\n          acc[face][options.cubeSize * i + j] = ColorName.Black\r\n        } else {\r\n          acc[face][options.cubeSize * i + j] = stickerColors[colorIndex]\r\n        }\r\n\r\n        if (mask && !mask[face][options.cubeSize * i + j]) {\r\n          acc[face][options.cubeSize * i + j] = ColorCode.DarkGray\r\n        }\r\n      }\r\n    }\r\n\r\n    return acc\r\n  }, {})\r\n\r\n  // Apply Algorithm\r\n  let cubeData = new CubeData(options.cubeSize, faceMappedStickers)\r\n\r\n  let alg: Turn[] = []\r\n\r\n  if (options.case) {\r\n    alg = parseCase(options.case)\r\n  } else if (options.algorithm) {\r\n    alg = parseAlgorithm(options.algorithm)\r\n  }\r\n\r\n  alg.forEach(move => {\r\n    cubeData.turn(move)\r\n  })\r\n\r\n  return [].concat.apply([], AllFaces.map(face => cubeData.faces[face].slice()))\r\n}\r\n","export type Vec3 = [number, number, number];\r\n\r\nexport const enum Axis {\r\n  X = 0,\r\n  Y = 1,\r\n  Z = 2\r\n}\r\n\r\nexport const Masking = {\r\n  FL: 'fl',\r\n  F2L: 'f2l',\r\n  LL: 'll',\r\n  CLL: 'cll',\r\n  ELL: 'ell',\r\n  OLL: 'oll',\r\n  OCLL: 'ocll',\r\n  OELL: 'oell',\r\n  COLL: 'coll',\r\n  OCELL: 'ocell',\r\n  WV: 'wv',\r\n  VH: 'vh',\r\n  ELS: 'els',\r\n  CLS: 'cls',\r\n  CMLL: 'cmll',\r\n  CROSS: 'cross',\r\n  F2L3: 'f2l_3',\r\n  F2L2: 'f2l_2',\r\n  F2LSM: 'f2l_sm',\r\n  F2L1: 'f2l_1',\r\n  F2B: 'f2b',\r\n  LINE: 'line'\r\n}\r\n\r\nexport const enum Face {\r\n  U = 0,\r\n  R = 1,\r\n  F = 2,\r\n  D = 3,\r\n  L = 4,\r\n  B = 5,\r\n}\r\n\r\nexport interface StickerDefinition {\r\n  face: Face;\r\n  n: number;\r\n}\r\n\r\nexport interface Arrow {\r\n  s1: StickerDefinition;\r\n  s2: StickerDefinition;\r\n  s3?: StickerDefinition;\r\n  scale: number;\r\n  influence: number;\r\n  color: string;\r\n}\r\n\r\nexport class CubeOptions {\r\n  dist?: number;\r\n  algorithm?: string;\r\n  backgroundColor?: string;\r\n  cubeColor?: string;\r\n  outlineWidth?: number;\r\n  strokeWidth?: number;\r\n  cubeSize?: number;\r\n  cubeOpacity?: number;\r\n  stickerOpacity?: number;\r\n  colorScheme?: { [face: number]: string };\r\n  stickerColors?: string[];\r\n  facelets?: string[];\r\n  zPosition?: Vec3;\r\n  viewportRotations?: [Axis, number][];\r\n  view?: string;\r\n  width?: number;\r\n  height?: number;\r\n  mask?: string;\r\n  maskAlg?: string;\r\n  arrows?: Arrow[] | string;\r\n  viewbox?: {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n  }\r\n}\r\n\r\nexport {CubeSvg} from \"./cubeSvg\""],"names":["ColorCode","ColorName","ColorAbbreviation","FaceletDefinition","Face","ColorNameToCode","Black","DarkGray","Gray","Silver","White","Yellow","Red","Orange","Blue","Green","Purple","Pink","ColorAbbreviationToCode","Transparent","FaceletAbbreviateToDefinition","u","Up","f","Front","r","Right","d","Down","l","Left","b","Back","t","o","Oriented","n","Blank","FaceletToFace","FaceletToColor","AlgorithmUnit","AllFaces","U","R","F","D","L","B","DefaultColorScheme","TurnAbbreviation","Masking","Axis","AxisSymbolToAxis","x","y","z","possibleMoves","M","E","S","X","Y","Z","cubeRotations","translate","pos","v","map","value","index","scale","scalar","transScale","rotate","axis","radians","newPosition","Math","cos","sin","makeStickerPosition","face","cubeSize","Error","parseColor","raw","exec","defaultFaceRotations","polygonPoints","points","point","join","Background","fill","options","fillOpacity","undefined","backgroundColor","React","Rect","viewbox","faceVisible","rotations","CubeOutlineGroup","G","opacity","cubeOpacity","strokeWidth","strokeLinejoin","children","OllLayerGroup","stickerOpacity","strokeOpacity","ArrowGroup","strokeLinecap","CubeOutline","length","width","outlineWidth","Polygon","cubeColor","stroke","FaceStickersSvg","stickers","stickerElements","i","j","centerPoint","p1","p2","p3","p4","color","getStickerColor","push","Sticker","key","stickerColor","props","row","col","colorIndex","indexOf","Array","isArray","facelets","stickerColors","fd","colorScheme","TurnType","OLLStickers","v1","v2","Fragment","ArrowSvg","geometry","arrow","p1y","floor","s1","p1x","p2y","s2","p2x","center","s3","p3y","p3x","influence","p_","rotation","atan","PI","Path","Cube","height","faceRotations","reduce","acc","forEach","rotateFaces","viewportRotations","renderOrder","sort","a","getRenderOrder","hiddenFaces","filter","visibleFaces","arrowDefinitions","arrows","split","part","match","RegExp","parseInt","parseArrow","Svg","viewBox","view","maskingFunctions","FL","F2L","LL","CLL","ELL","OLL","OCLL","OELL","COLL","OCELL","WV","VH","ELS","CLS","CMLL","CROSS","F2L3","F2L2","F2LSM","F2L1","F2B","LINE","faceIdentity","stickerNumber","counterClockwiseSticker","clockwiseSticker","doubleTurn","OppositeTurn","Clockwise","CounterClockwise","Double","AxisOrientation","CubeData","initialValues","this","numStickers","clockwiseMapping","counterClockwiseMapping","doubleMapping","faces","initValues","currentValue","_this","rotateFace","turn","newStickerNumber","_this2","reverse","axisRotation","offset","range","faceOrder","forward","double","originalValues","_this3","slice","stickerIndex","nextFace","valueIndex","nextFaceValueIndex","xLayersRotation","yLayersRotation","zLayersRotation","safeSlices","rTurn","turnType","slices","lTurn","uTurn","dTurn","fTurn","bTurn","mTurn","eTurn","sTurn","xTurn","yTurn","zTurn","move","JSON","stringify","turnRegex","Opposite","parseAlgorithm","algorithm","turns","rawSlices","rawFace","outerBlockIndicator","rawType","isLowerCaseMove","toLowerCase","toUpperCase","getMove","getTurnType","getSlices","parseFaceletDefinitions","rawValue","colors","charAt","defaultOptions","dist","extraOptions","parsedOptions","rawOptions","params","url","query","pairs","substr","pair","decodeURIComponent","parseQuery","Object","keys","paramValue","size","mask","rawSequence","rotationRegex","matchText","axisSymbol","parseRotationSequence","parsed","parseFaceletColors","scheme","rawColors","parsedColor","parseCommaSeparatedValues","parseAbbreviations","console","warn","parseOptions","getOptions","rows","cols","matrix","c","makeMatrix","sticker","makeFaceStickers","makeCubeGeometry","masking","faceValues","makeMasking","maskAlg","maskCubeData","concat","apply","faceMappedStickers","cubeData","alg","makeStickerColors"],"mappings":"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"}